{"ast":null,"code":"/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n\n/*global esprima:true, define:true, exports:true, window: true,\nthrowErrorTolerant: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseUnaryExpression: true,\nparseStatement: true, parseSourceElement: true */\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8,\n    RegularExpression: 9\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression'; // A function following one of those tokens is an expression.\n\n  FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void', // assignment operators\n  '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',', // binary/unary operators\n  '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    ArrayExpression: 'ArrayExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SwitchStatement: 'SwitchStatement',\n    SwitchCase: 'SwitchCase',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement'\n  };\n  PropertyKind = {\n    Data: 1,\n    Get: 2,\n    Set: 4\n  }; // Error messages should be identical to V8.\n\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n    AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n    AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode'\n  }; // See also tools/generate-unicode-regex.py.\n\n  Regex = {\n    NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n    NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  }; // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n\n  function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0..9\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  } // 7.2 White Space\n\n\n  function isWhiteSpace(ch) {\n    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;\n  } // 7.3 Line Terminators\n\n\n  function isLineTerminator(ch) {\n    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n  } // 7.6 Identifier Names and Identifiers\n\n\n  function isIdentifierStart(ch) {\n    return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A || // A..Z\n    ch >= 0x61 && ch <= 0x7A || // a..z\n    ch === 0x5C || // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));\n  }\n\n  function isIdentifierPart(ch) {\n    return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A || // A..Z\n    ch >= 0x61 && ch <= 0x7A || // a..z\n    ch >= 0x30 && ch <= 0x39 || // 0..9\n    ch === 0x5C || // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));\n  } // 7.6.1.2 Future Reserved Words\n\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  } // 7.6.1.1 Keywords\n\n\n  function isKeyword(id) {\n    if (strict && isStrictModeReservedWord(id)) {\n      return true;\n    } // 'const' is specialized as Keyword in V8.\n    // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n    // Some others are from future reserved words.\n\n\n    switch (id.length) {\n      case 2:\n        return id === 'if' || id === 'in' || id === 'do';\n\n      case 3:\n        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n\n      case 4:\n        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n\n      case 5:\n        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n\n      case 6:\n        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n\n      case 7:\n        return id === 'default' || id === 'finally' || id === 'extends';\n\n      case 8:\n        return id === 'function' || id === 'continue' || id === 'debugger';\n\n      case 10:\n        return id === 'instanceof';\n\n      default:\n        return false;\n    }\n  } // 7.4 Comments\n\n\n  function addComment(type, value, start, end, loc) {\n    var comment, attacher;\n    assert(typeof start === 'number', 'Comment must have valid position'); // Because the way the actual token is scanned, often the comments\n    // (if any) are skipped twice during the lexical analysis.\n    // Thus, we need to skip adding a comment if the comment array already\n    // handled it.\n\n    if (state.lastCommentStart >= start) {\n      return;\n    }\n\n    state.lastCommentStart = start;\n    comment = {\n      type: type,\n      value: value\n    };\n\n    if (extra.range) {\n      comment.range = [start, end];\n    }\n\n    if (extra.loc) {\n      comment.loc = loc;\n    }\n\n    extra.comments.push(comment);\n\n    if (extra.attachComment) {\n      extra.leadingComments.push(comment);\n      extra.trailingComments.push(comment);\n    }\n  }\n\n  function skipSingleLineComment(offset) {\n    var start, loc, ch, comment;\n    start = index - offset;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart - offset\n      }\n    };\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      ++index;\n\n      if (isLineTerminator(ch)) {\n        if (extra.comments) {\n          comment = source.slice(start + offset, index - 1);\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          addComment('Line', comment, start, index - 1, loc);\n        }\n\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n        return;\n      }\n    }\n\n    if (extra.comments) {\n      comment = source.slice(start + offset, index);\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      addComment('Line', comment, start, index, loc);\n    }\n  }\n\n  function skipMultiLineComment() {\n    var start, loc, ch, comment;\n\n    if (extra.comments) {\n      start = index - 2;\n      loc = {\n        start: {\n          line: lineNumber,\n          column: index - lineStart - 2\n        }\n      };\n    }\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (isLineTerminator(ch)) {\n        if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n          ++index;\n        }\n\n        ++lineNumber;\n        ++index;\n        lineStart = index;\n\n        if (index >= length) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      } else if (ch === 0x2A) {\n        // Block comment ends with '*/'.\n        if (source.charCodeAt(index + 1) === 0x2F) {\n          ++index;\n          ++index;\n\n          if (extra.comments) {\n            comment = source.slice(start + 2, index - 2);\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            addComment('Block', comment, start, index, loc);\n          }\n\n          return;\n        }\n\n        ++index;\n      } else {\n        ++index;\n      }\n    }\n\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  function skipComment() {\n    var ch, start;\n    start = index === 0;\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        ++index;\n\n        if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n          ++index;\n        }\n\n        ++lineNumber;\n        lineStart = index;\n        start = true;\n      } else if (ch === 0x2F) {\n        // U+002F is '/'\n        ch = source.charCodeAt(index + 1);\n\n        if (ch === 0x2F) {\n          ++index;\n          ++index;\n          skipSingleLineComment(2);\n          start = true;\n        } else if (ch === 0x2A) {\n          // U+002A is '*'\n          ++index;\n          ++index;\n          skipMultiLineComment();\n        } else {\n          break;\n        }\n      } else if (start && ch === 0x2D) {\n        // U+002D is '-'\n        // U+003E is '>'\n        if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {\n          // '-->' is a single-line comment\n          index += 3;\n          skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (ch === 0x3C) {\n        // U+003C is '<'\n        if (source.slice(index + 1, index + 4) === '!--') {\n          ++index; // `<`\n\n          ++index; // `!`\n\n          ++index; // `-`\n\n          ++index; // `-`\n\n          skipSingleLineComment(4);\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  function scanHexEscape(prefix) {\n    var i,\n        len,\n        ch,\n        code = 0;\n    len = prefix === 'u' ? 4 : 2;\n\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n\n    return String.fromCharCode(code);\n  }\n\n  function getEscapedIdentifier() {\n    var ch, id;\n    ch = source.charCodeAt(index++);\n    id = String.fromCharCode(ch); // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n    if (ch === 0x5C) {\n      if (source.charCodeAt(index) !== 0x75) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      ++index;\n      ch = scanHexEscape('u');\n\n      if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      id = ch;\n    }\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n\n      ++index;\n      id += String.fromCharCode(ch); // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n      if (ch === 0x5C) {\n        id = id.substr(0, id.length - 1);\n\n        if (source.charCodeAt(index) !== 0x75) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        ++index;\n        ch = scanHexEscape('u');\n\n        if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        id += ch;\n      }\n    }\n\n    return id;\n  }\n\n  function getIdentifier() {\n    var start, ch;\n    start = index++;\n\n    while (index < length) {\n      ch = source.charCodeAt(index);\n\n      if (ch === 0x5C) {\n        // Blackslash (U+005C) marks Unicode escape sequence.\n        index = start;\n        return getEscapedIdentifier();\n      }\n\n      if (isIdentifierPart(ch)) {\n        ++index;\n      } else {\n        break;\n      }\n    }\n\n    return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n    var start, id, type;\n    start = index; // Backslash (U+005C) starts an escaped character.\n\n    id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n\n    if (id.length === 1) {\n      type = Token.Identifier;\n    } else if (isKeyword(id)) {\n      type = Token.Keyword;\n    } else if (id === 'null') {\n      type = Token.NullLiteral;\n    } else if (id === 'true' || id === 'false') {\n      type = Token.BooleanLiteral;\n    } else {\n      type = Token.Identifier;\n    }\n\n    return {\n      type: type,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // 7.7 Punctuators\n\n\n  function scanPunctuator() {\n    var start = index,\n        code = source.charCodeAt(index),\n        code2,\n        ch1 = source[index],\n        ch2,\n        ch3,\n        ch4;\n\n    switch (code) {\n      // Check for most common single-character punctuators.\n      case 0x2E: // . dot\n\n      case 0x28: // ( open bracket\n\n      case 0x29: // ) close bracket\n\n      case 0x3B: // ; semicolon\n\n      case 0x2C: // , comma\n\n      case 0x7B: // { open curly brace\n\n      case 0x7D: // } close curly brace\n\n      case 0x5B: // [\n\n      case 0x5D: // ]\n\n      case 0x3A: // :\n\n      case 0x3F: // ?\n\n      case 0x7E:\n        // ~\n        ++index;\n\n        if (extra.tokenize) {\n          if (code === 0x28) {\n            extra.openParenToken = extra.tokens.length;\n          } else if (code === 0x7B) {\n            extra.openCurlyToken = extra.tokens.length;\n          }\n        }\n\n        return {\n          type: Token.Punctuator,\n          value: String.fromCharCode(code),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n        };\n\n      default:\n        code2 = source.charCodeAt(index + 1); // '=' (U+003D) marks an assignment or comparison operator.\n\n        if (code2 === 0x3D) {\n          switch (code) {\n            case 0x2B: // +\n\n            case 0x2D: // -\n\n            case 0x2F: // /\n\n            case 0x3C: // <\n\n            case 0x3E: // >\n\n            case 0x5E: // ^\n\n            case 0x7C: // |\n\n            case 0x25: // %\n\n            case 0x26: // &\n\n            case 0x2A:\n              // *\n              index += 2;\n              return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code) + String.fromCharCode(code2),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n              };\n\n            case 0x21: // !\n\n            case 0x3D:\n              // =\n              index += 2; // !== and ===\n\n              if (source.charCodeAt(index) === 0x3D) {\n                ++index;\n              }\n\n              return {\n                type: Token.Punctuator,\n                value: source.slice(start, index),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n              };\n          }\n        }\n\n    } // 4-character punctuator: >>>=\n\n\n    ch4 = source.substr(index, 4);\n\n    if (ch4 === '>>>=') {\n      index += 4;\n      return {\n        type: Token.Punctuator,\n        value: ch4,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    } // 3-character punctuators: === !== >>> <<= >>=\n\n\n    ch3 = ch4.substr(0, 3);\n\n    if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: ch3,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    } // Other 2-character punctuators: ++ -- << >> && ||\n\n\n    ch2 = ch3.substr(0, 2);\n\n    if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {\n      index += 2;\n      return {\n        type: Token.Punctuator,\n        value: ch2,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    } // 1-character punctuators: < > = ! + - * % & | ^ /\n\n\n    if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  } // 7.8.3 Numeric Literals\n\n\n  function scanHexLiteral(start) {\n    var number = '';\n\n    while (index < length) {\n      if (!isHexDigit(source[index])) {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (number.length === 0) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt('0x' + number, 16),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function scanOctalLiteral(start) {\n    var number = '0' + source[index++];\n\n    while (index < length) {\n      if (!isOctalDigit(source[index])) {\n        break;\n      }\n\n      number += source[index++];\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 8),\n      octal: true,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function isImplicitOctalLiteral() {\n    var i, ch; // Implicit octal, unless there is a non-octal digit.\n    // (Annex B.1.1 on Numeric Literals)\n\n    for (i = index + 1; i < length; ++i) {\n      ch = source[i];\n\n      if (ch === '8' || ch === '9') {\n        return false;\n      }\n\n      if (!isOctalDigit(ch)) {\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index]; // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          ++index;\n          return scanHexLiteral(start);\n        }\n\n        if (isOctalDigit(ch)) {\n          if (isImplicitOctalLiteral()) {\n            return scanOctalLiteral(start);\n          }\n        }\n      }\n\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n\n      ch = source[index];\n    }\n\n    if (ch === '.') {\n      number += source[index++];\n\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n\n      ch = source[index];\n    }\n\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n\n      if (isDecimalDigit(source.charCodeAt(index))) {\n        while (isDecimalDigit(source.charCodeAt(index))) {\n          number += source[index++];\n        }\n      } else {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  } // 7.8.4 String Literals\n\n\n  function scanStringLiteral() {\n    var str = '',\n        quote,\n        start,\n        ch,\n        code,\n        unescaped,\n        restore,\n        octal = false,\n        startLineNumber,\n        startLineStart;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n\n    while (index < length) {\n      ch = source[index++];\n\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n\n        if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'u':\n            case 'x':\n              restore = index;\n              unescaped = scanHexEscape(ch);\n\n              if (unescaped) {\n                str += unescaped;\n              } else {\n                index = restore;\n                str += ch;\n              }\n\n              break;\n\n            case 'n':\n              str += '\\n';\n              break;\n\n            case 'r':\n              str += '\\r';\n              break;\n\n            case 't':\n              str += '\\t';\n              break;\n\n            case 'b':\n              str += '\\b';\n              break;\n\n            case 'f':\n              str += '\\f';\n              break;\n\n            case 'v':\n              str += '\\x0B';\n              break;\n\n            default:\n              if (isOctalDigit(ch)) {\n                code = '01234567'.indexOf(ch); // \\0 is not octal escape sequence\n\n                if (code !== 0) {\n                  octal = true;\n                }\n\n                if (index < length && isOctalDigit(source[index])) {\n                  octal = true;\n                  code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n\n                  if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                  }\n                }\n\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n\n              break;\n          }\n        } else {\n          ++lineNumber;\n\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (quote !== '') {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      startLineNumber: startLineNumber,\n      startLineStart: startLineStart,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  function testRegExp(pattern, flags) {\n    var value;\n\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      throwError({}, Messages.InvalidRegExp);\n    }\n\n    return value;\n  }\n\n  function scanRegExpBody() {\n    var ch, str, classMarker, terminated, body;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n    classMarker = false;\n    terminated = false;\n\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n\n      if (ch === '\\\\') {\n        ch = source[index++]; // ECMA-262 7.8.5\n\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        str += ch;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throwError({}, Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n      }\n    }\n\n    if (!terminated) {\n      throwError({}, Messages.UnterminatedRegExp);\n    } // Exclude leading and trailing slash.\n\n\n    body = str.substr(1, str.length - 2);\n    return {\n      value: body,\n      literal: str\n    };\n  }\n\n  function scanRegExpFlags() {\n    var ch, str, flags, restore;\n    str = '';\n    flags = '';\n\n    while (index < length) {\n      ch = source[index];\n\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n\n      ++index;\n\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n\n          if (ch) {\n            flags += ch;\n\n            for (str += '\\\\u'; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += '\\\\u';\n          }\n\n          throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n        } else {\n          str += '\\\\';\n          throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n\n    return {\n      value: flags,\n      literal: str\n    };\n  }\n\n  function scanRegExp() {\n    var start, body, flags, pattern, value;\n    lookahead = null;\n    skipComment();\n    start = index;\n    body = scanRegExpBody();\n    flags = scanRegExpFlags();\n    value = testRegExp(body.value, flags.value);\n\n    if (extra.tokenize) {\n      return {\n        type: Token.RegularExpression,\n        value: value,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n\n    return {\n      literal: body.literal + flags.literal,\n      value: value,\n      start: start,\n      end: index\n    };\n  }\n\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    /* istanbul ignore next */\n\n    if (!extra.tokenize) {\n      // Pop the previous token, which is likely '/' or '/='\n      if (extra.tokens.length > 0) {\n        token = extra.tokens[extra.tokens.length - 1];\n\n        if (token.range[0] === pos && token.type === 'Punctuator') {\n          if (token.value === '/' || token.value === '/=') {\n            extra.tokens.pop();\n          }\n        }\n      }\n\n      extra.tokens.push({\n        type: 'RegularExpression',\n        value: regex.literal,\n        range: [pos, index],\n        loc: loc\n      });\n    }\n\n    return regex;\n  }\n\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n    var prevToken, checkToken; // Using the following algorithm:\n    // https://github.com/mozilla/sweet.js/wiki/design\n\n    prevToken = extra.tokens[extra.tokens.length - 1];\n\n    if (!prevToken) {\n      // Nothing before that: it cannot be a division.\n      return collectRegex();\n    }\n\n    if (prevToken.type === 'Punctuator') {\n      if (prevToken.value === ']') {\n        return scanPunctuator();\n      }\n\n      if (prevToken.value === ')') {\n        checkToken = extra.tokens[extra.openParenToken - 1];\n\n        if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {\n          return collectRegex();\n        }\n\n        return scanPunctuator();\n      }\n\n      if (prevToken.value === '}') {\n        // Dividing a function by anything makes little sense,\n        // but we have to check for that.\n        if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n          // Anonymous function.\n          checkToken = extra.tokens[extra.openCurlyToken - 4];\n\n          if (!checkToken) {\n            return scanPunctuator();\n          }\n        } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n          // Named function.\n          checkToken = extra.tokens[extra.openCurlyToken - 5];\n\n          if (!checkToken) {\n            return collectRegex();\n          }\n        } else {\n          return scanPunctuator();\n        } // checkToken determines whether the function is\n        // a declaration or an expression.\n\n\n        if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n          // It is an expression.\n          return scanPunctuator();\n        } // It is a declaration.\n\n\n        return collectRegex();\n      }\n\n      return collectRegex();\n    }\n\n    if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n      return collectRegex();\n    }\n\n    return scanPunctuator();\n  }\n\n  function advance() {\n    var ch;\n    skipComment();\n\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: index,\n        end: index\n      };\n    }\n\n    ch = source.charCodeAt(index);\n\n    if (isIdentifierStart(ch)) {\n      return scanIdentifier();\n    } // Very common: ( and ) and ;\n\n\n    if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n      return scanPunctuator();\n    } // String literal starts with single quote (U+0027) or double quote (U+0022).\n\n\n    if (ch === 0x27 || ch === 0x22) {\n      return scanStringLiteral();\n    } // Dot (.) U+002E can also start a floating-point number, hence the need\n    // to check the next character.\n\n\n    if (ch === 0x2E) {\n      if (isDecimalDigit(source.charCodeAt(index + 1))) {\n        return scanNumericLiteral();\n      }\n\n      return scanPunctuator();\n    }\n\n    if (isDecimalDigit(ch)) {\n      return scanNumericLiteral();\n    } // Slash (/) U+002F can also start a regex.\n\n\n    if (extra.tokenize && ch === 0x2F) {\n      return advanceSlash();\n    }\n\n    return scanPunctuator();\n  }\n\n  function collectToken() {\n    var loc, token, range, value;\n    skipComment();\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    if (token.type !== Token.EOF) {\n      value = source.slice(token.start, token.end);\n      extra.tokens.push({\n        type: TokenName[token.type],\n        value: value,\n        range: [token.start, token.end],\n        loc: loc\n      });\n    }\n\n    return token;\n  }\n\n  function lex() {\n    var token;\n    token = lookahead;\n    index = token.end;\n    lineNumber = token.lineNumber;\n    lineStart = token.lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    index = token.end;\n    lineNumber = token.lineNumber;\n    lineStart = token.lineStart;\n    return token;\n  }\n\n  function peek() {\n    var pos, line, start;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n  }\n\n  function Position(line, column) {\n    this.line = line;\n    this.column = column;\n  }\n\n  function SourceLocation(startLine, startColumn, line, column) {\n    this.start = new Position(startLine, startColumn);\n    this.end = new Position(line, column);\n  }\n\n  SyntaxTreeDelegate = {\n    name: 'SyntaxTree',\n    processComment: function (node) {\n      var lastChild, trailingComments;\n\n      if (node.type === Syntax.Program) {\n        if (node.body.length > 0) {\n          return;\n        }\n      }\n\n      if (extra.trailingComments.length > 0) {\n        if (extra.trailingComments[0].range[0] >= node.range[1]) {\n          trailingComments = extra.trailingComments;\n          extra.trailingComments = [];\n        } else {\n          extra.trailingComments.length = 0;\n        }\n      } else {\n        if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {\n          trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n          delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n        }\n      } // Eating the stack.\n\n\n      while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {\n        lastChild = extra.bottomRightStack.pop();\n      }\n\n      if (lastChild) {\n        if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        }\n      } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n        node.leadingComments = extra.leadingComments;\n        extra.leadingComments = [];\n      }\n\n      if (trailingComments) {\n        node.trailingComments = trailingComments;\n      }\n\n      extra.bottomRightStack.push(node);\n    },\n    markEnd: function (node, startToken) {\n      if (extra.range) {\n        node.range = [startToken.start, index];\n      }\n\n      if (extra.loc) {\n        node.loc = new SourceLocation(startToken.startLineNumber === undefined ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === undefined ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);\n        this.postProcess(node);\n      }\n\n      if (extra.attachComment) {\n        this.processComment(node);\n      }\n\n      return node;\n    },\n    postProcess: function (node) {\n      if (extra.source) {\n        node.loc.source = extra.source;\n      }\n\n      return node;\n    },\n    createArrayExpression: function (elements) {\n      return {\n        type: Syntax.ArrayExpression,\n        elements: elements\n      };\n    },\n    createAssignmentExpression: function (operator, left, right) {\n      return {\n        type: Syntax.AssignmentExpression,\n        operator: operator,\n        left: left,\n        right: right\n      };\n    },\n    createBinaryExpression: function (operator, left, right) {\n      var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n      return {\n        type: type,\n        operator: operator,\n        left: left,\n        right: right\n      };\n    },\n    createBlockStatement: function (body) {\n      return {\n        type: Syntax.BlockStatement,\n        body: body\n      };\n    },\n    createBreakStatement: function (label) {\n      return {\n        type: Syntax.BreakStatement,\n        label: label\n      };\n    },\n    createCallExpression: function (callee, args) {\n      return {\n        type: Syntax.CallExpression,\n        callee: callee,\n        'arguments': args\n      };\n    },\n    createCatchClause: function (param, body) {\n      return {\n        type: Syntax.CatchClause,\n        param: param,\n        body: body\n      };\n    },\n    createConditionalExpression: function (test, consequent, alternate) {\n      return {\n        type: Syntax.ConditionalExpression,\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    },\n    createContinueStatement: function (label) {\n      return {\n        type: Syntax.ContinueStatement,\n        label: label\n      };\n    },\n    createDebuggerStatement: function () {\n      return {\n        type: Syntax.DebuggerStatement\n      };\n    },\n    createDoWhileStatement: function (body, test) {\n      return {\n        type: Syntax.DoWhileStatement,\n        body: body,\n        test: test\n      };\n    },\n    createEmptyStatement: function () {\n      return {\n        type: Syntax.EmptyStatement\n      };\n    },\n    createExpressionStatement: function (expression) {\n      return {\n        type: Syntax.ExpressionStatement,\n        expression: expression\n      };\n    },\n    createForStatement: function (init, test, update, body) {\n      return {\n        type: Syntax.ForStatement,\n        init: init,\n        test: test,\n        update: update,\n        body: body\n      };\n    },\n    createForInStatement: function (left, right, body) {\n      return {\n        type: Syntax.ForInStatement,\n        left: left,\n        right: right,\n        body: body,\n        each: false\n      };\n    },\n    createFunctionDeclaration: function (id, params, defaults, body) {\n      return {\n        type: Syntax.FunctionDeclaration,\n        id: id,\n        params: params,\n        defaults: defaults,\n        body: body,\n        rest: null,\n        generator: false,\n        expression: false\n      };\n    },\n    createFunctionExpression: function (id, params, defaults, body) {\n      return {\n        type: Syntax.FunctionExpression,\n        id: id,\n        params: params,\n        defaults: defaults,\n        body: body,\n        rest: null,\n        generator: false,\n        expression: false\n      };\n    },\n    createIdentifier: function (name) {\n      return {\n        type: Syntax.Identifier,\n        name: name\n      };\n    },\n    createIfStatement: function (test, consequent, alternate) {\n      return {\n        type: Syntax.IfStatement,\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    },\n    createLabeledStatement: function (label, body) {\n      return {\n        type: Syntax.LabeledStatement,\n        label: label,\n        body: body\n      };\n    },\n    createLiteral: function (token) {\n      return {\n        type: Syntax.Literal,\n        value: token.value,\n        raw: source.slice(token.start, token.end)\n      };\n    },\n    createMemberExpression: function (accessor, object, property) {\n      return {\n        type: Syntax.MemberExpression,\n        computed: accessor === '[',\n        object: object,\n        property: property\n      };\n    },\n    createNewExpression: function (callee, args) {\n      return {\n        type: Syntax.NewExpression,\n        callee: callee,\n        'arguments': args\n      };\n    },\n    createObjectExpression: function (properties) {\n      return {\n        type: Syntax.ObjectExpression,\n        properties: properties\n      };\n    },\n    createPostfixExpression: function (operator, argument) {\n      return {\n        type: Syntax.UpdateExpression,\n        operator: operator,\n        argument: argument,\n        prefix: false\n      };\n    },\n    createProgram: function (body) {\n      return {\n        type: Syntax.Program,\n        body: body\n      };\n    },\n    createProperty: function (kind, key, value) {\n      return {\n        type: Syntax.Property,\n        key: key,\n        value: value,\n        kind: kind\n      };\n    },\n    createReturnStatement: function (argument) {\n      return {\n        type: Syntax.ReturnStatement,\n        argument: argument\n      };\n    },\n    createSequenceExpression: function (expressions) {\n      return {\n        type: Syntax.SequenceExpression,\n        expressions: expressions\n      };\n    },\n    createSwitchCase: function (test, consequent) {\n      return {\n        type: Syntax.SwitchCase,\n        test: test,\n        consequent: consequent\n      };\n    },\n    createSwitchStatement: function (discriminant, cases) {\n      return {\n        type: Syntax.SwitchStatement,\n        discriminant: discriminant,\n        cases: cases\n      };\n    },\n    createThisExpression: function () {\n      return {\n        type: Syntax.ThisExpression\n      };\n    },\n    createThrowStatement: function (argument) {\n      return {\n        type: Syntax.ThrowStatement,\n        argument: argument\n      };\n    },\n    createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n      return {\n        type: Syntax.TryStatement,\n        block: block,\n        guardedHandlers: guardedHandlers,\n        handlers: handlers,\n        finalizer: finalizer\n      };\n    },\n    createUnaryExpression: function (operator, argument) {\n      if (operator === '++' || operator === '--') {\n        return {\n          type: Syntax.UpdateExpression,\n          operator: operator,\n          argument: argument,\n          prefix: true\n        };\n      }\n\n      return {\n        type: Syntax.UnaryExpression,\n        operator: operator,\n        argument: argument,\n        prefix: true\n      };\n    },\n    createVariableDeclaration: function (declarations, kind) {\n      return {\n        type: Syntax.VariableDeclaration,\n        declarations: declarations,\n        kind: kind\n      };\n    },\n    createVariableDeclarator: function (id, init) {\n      return {\n        type: Syntax.VariableDeclarator,\n        id: id,\n        init: init\n      };\n    },\n    createWhileStatement: function (test, body) {\n      return {\n        type: Syntax.WhileStatement,\n        test: test,\n        body: body\n      };\n    },\n    createWithStatement: function (object, body) {\n      return {\n        type: Syntax.WithStatement,\n        object: object,\n        body: body\n      };\n    }\n  }; // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n    var pos, line, start, found;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    skipComment();\n    found = lineNumber !== line;\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return found;\n  } // Throw an exception\n\n\n  function throwError(token, messageFormat) {\n    var error,\n        args = Array.prototype.slice.call(arguments, 2),\n        msg = messageFormat.replace(/%(\\d)/g, function (whole, index) {\n      assert(index < args.length, 'Message reference must be in range');\n      return args[index];\n    });\n\n    if (typeof token.lineNumber === 'number') {\n      error = new Error('Line ' + token.lineNumber + ': ' + msg);\n      error.index = token.start;\n      error.lineNumber = token.lineNumber;\n      error.column = token.start - lineStart + 1;\n    } else {\n      error = new Error('Line ' + lineNumber + ': ' + msg);\n      error.index = index;\n      error.lineNumber = lineNumber;\n      error.column = index - lineStart + 1;\n    }\n\n    error.description = msg;\n    throw error;\n  }\n\n  function throwErrorTolerant() {\n    try {\n      throwError.apply(null, arguments);\n    } catch (e) {\n      if (extra.errors) {\n        extra.errors.push(e);\n      } else {\n        throw e;\n      }\n    }\n  } // Throw an exception because of the token.\n\n\n  function throwUnexpected(token) {\n    if (token.type === Token.EOF) {\n      throwError(token, Messages.UnexpectedEOS);\n    }\n\n    if (token.type === Token.NumericLiteral) {\n      throwError(token, Messages.UnexpectedNumber);\n    }\n\n    if (token.type === Token.StringLiteral) {\n      throwError(token, Messages.UnexpectedString);\n    }\n\n    if (token.type === Token.Identifier) {\n      throwError(token, Messages.UnexpectedIdentifier);\n    }\n\n    if (token.type === Token.Keyword) {\n      if (isFutureReservedWord(token.value)) {\n        throwError(token, Messages.UnexpectedReserved);\n      } else if (strict && isStrictModeReservedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictReservedWord);\n        return;\n      }\n\n      throwError(token, Messages.UnexpectedToken, token.value);\n    } // BooleanLiteral, NullLiteral, or Punctuator.\n\n\n    throwError(token, Messages.UnexpectedToken, token.value);\n  } // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n\n  function expect(value) {\n    var token = lex();\n\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpected(token);\n    }\n  } // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n\n  function expectKeyword(keyword) {\n    var token = lex();\n\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpected(token);\n    }\n  } // Return true if the next token matches the specified punctuator.\n\n\n  function match(value) {\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\n  } // Return true if the next token matches the specified keyword\n\n\n  function matchKeyword(keyword) {\n    return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  } // Return true if the next token is an assignment operator\n\n\n  function matchAssign() {\n    var op;\n\n    if (lookahead.type !== Token.Punctuator) {\n      return false;\n    }\n\n    op = lookahead.value;\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n\n  function consumeSemicolon() {\n    var line,\n        oldIndex = index,\n        oldLineNumber = lineNumber,\n        oldLineStart = lineStart,\n        oldLookahead = lookahead; // Catch the very common case first: immediately a semicolon (U+003B).\n\n    if (source.charCodeAt(index) === 0x3B || match(';')) {\n      lex();\n      return;\n    }\n\n    line = lineNumber;\n    skipComment();\n\n    if (lineNumber !== line) {\n      index = oldIndex;\n      lineNumber = oldLineNumber;\n      lineStart = oldLineStart;\n      lookahead = oldLookahead;\n      return;\n    }\n\n    if (lookahead.type !== Token.EOF && !match('}')) {\n      throwUnexpected(lookahead);\n    }\n  } // Return true if provided expression is LeftHandSideExpression\n\n\n  function isLeftHandSide(expr) {\n    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  } // 11.1.4 Array Initialiser\n\n\n  function parseArrayInitialiser() {\n    var elements = [],\n        startToken;\n    startToken = lookahead;\n    expect('[');\n\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        elements.push(parseAssignmentExpression());\n\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n\n    lex();\n    return delegate.markEnd(delegate.createArrayExpression(elements), startToken);\n  } // 11.1.5 Object Initialiser\n\n\n  function parsePropertyFunction(param, first) {\n    var previousStrict, body, startToken;\n    previousStrict = strict;\n    startToken = lookahead;\n    body = parseFunctionSourceElements();\n\n    if (first && strict && isRestrictedWord(param[0].name)) {\n      throwErrorTolerant(first, Messages.StrictParamName);\n    }\n\n    strict = previousStrict;\n    return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);\n  }\n\n  function parseObjectPropertyKey() {\n    var token, startToken;\n    startToken = lookahead;\n    token = lex(); // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n      if (strict && token.octal) {\n        throwErrorTolerant(token, Messages.StrictOctalLiteral);\n      }\n\n      return delegate.markEnd(delegate.createLiteral(token), startToken);\n    }\n\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n  }\n\n  function parseObjectProperty() {\n    var token, key, id, value, param, startToken;\n    token = lookahead;\n    startToken = lookahead;\n\n    if (token.type === Token.Identifier) {\n      id = parseObjectPropertyKey(); // Property Assignment: Getter and Setter.\n\n      if (token.value === 'get' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        expect(')');\n        value = parsePropertyFunction([]);\n        return delegate.markEnd(delegate.createProperty('get', key, value), startToken);\n      }\n\n      if (token.value === 'set' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        token = lookahead;\n\n        if (token.type !== Token.Identifier) {\n          expect(')');\n          throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          value = parsePropertyFunction([]);\n        } else {\n          param = [parseVariableIdentifier()];\n          expect(')');\n          value = parsePropertyFunction(param, token);\n        }\n\n        return delegate.markEnd(delegate.createProperty('set', key, value), startToken);\n      }\n\n      expect(':');\n      value = parseAssignmentExpression();\n      return delegate.markEnd(delegate.createProperty('init', id, value), startToken);\n    }\n\n    if (token.type === Token.EOF || token.type === Token.Punctuator) {\n      throwUnexpected(token);\n    } else {\n      key = parseObjectPropertyKey();\n      expect(':');\n      value = parseAssignmentExpression();\n      return delegate.markEnd(delegate.createProperty('init', key, value), startToken);\n    }\n  }\n\n  function parseObjectInitialiser() {\n    var properties = [],\n        property,\n        name,\n        key,\n        kind,\n        map = {},\n        toString = String,\n        startToken;\n    startToken = lookahead;\n    expect('{');\n\n    while (!match('}')) {\n      property = parseObjectProperty();\n\n      if (property.key.type === Syntax.Identifier) {\n        name = property.key.name;\n      } else {\n        name = toString(property.key.value);\n      }\n\n      kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;\n      key = '$' + name;\n\n      if (Object.prototype.hasOwnProperty.call(map, key)) {\n        if (map[key] === PropertyKind.Data) {\n          if (strict && kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n          } else if (kind !== PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          }\n        } else {\n          if (kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          } else if (map[key] & kind) {\n            throwErrorTolerant({}, Messages.AccessorGetSet);\n          }\n        }\n\n        map[key] |= kind;\n      } else {\n        map[key] = kind;\n      }\n\n      properties.push(property);\n\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n\n    expect('}');\n    return delegate.markEnd(delegate.createObjectExpression(properties), startToken);\n  } // 11.1.6 The Grouping Operator\n\n\n  function parseGroupExpression() {\n    var expr;\n    expect('(');\n    expr = parseExpression();\n    expect(')');\n    return expr;\n  } // 11.1 Primary Expressions\n\n\n  function parsePrimaryExpression() {\n    var type, token, expr, startToken;\n\n    if (match('(')) {\n      return parseGroupExpression();\n    }\n\n    if (match('[')) {\n      return parseArrayInitialiser();\n    }\n\n    if (match('{')) {\n      return parseObjectInitialiser();\n    }\n\n    type = lookahead.type;\n    startToken = lookahead;\n\n    if (type === Token.Identifier) {\n      expr = delegate.createIdentifier(lex().value);\n    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      if (strict && lookahead.octal) {\n        throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n      }\n\n      expr = delegate.createLiteral(lex());\n    } else if (type === Token.Keyword) {\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n\n      if (matchKeyword('this')) {\n        lex();\n        expr = delegate.createThisExpression();\n      } else {\n        throwUnexpected(lex());\n      }\n    } else if (type === Token.BooleanLiteral) {\n      token = lex();\n      token.value = token.value === 'true';\n      expr = delegate.createLiteral(token);\n    } else if (type === Token.NullLiteral) {\n      token = lex();\n      token.value = null;\n      expr = delegate.createLiteral(token);\n    } else if (match('/') || match('/=')) {\n      if (typeof extra.tokens !== 'undefined') {\n        expr = delegate.createLiteral(collectRegex());\n      } else {\n        expr = delegate.createLiteral(scanRegExp());\n      }\n\n      peek();\n    } else {\n      throwUnexpected(lex());\n    }\n\n    return delegate.markEnd(expr, startToken);\n  } // 11.2 Left-Hand-Side Expressions\n\n\n  function parseArguments() {\n    var args = [];\n    expect('(');\n\n    if (!match(')')) {\n      while (index < length) {\n        args.push(parseAssignmentExpression());\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    return args;\n  }\n\n  function parseNonComputedProperty() {\n    var token, startToken;\n    startToken = lookahead;\n    token = lex();\n\n    if (!isIdentifierName(token)) {\n      throwUnexpected(token);\n    }\n\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n  }\n\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = parseExpression();\n    expect(']');\n    return expr;\n  }\n\n  function parseNewExpression() {\n    var callee, args, startToken;\n    startToken = lookahead;\n    expectKeyword('new');\n    callee = parseLeftHandSideExpression();\n    args = match('(') ? parseArguments() : [];\n    return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n    var expr,\n        args,\n        property,\n        startToken,\n        previousAllowIn = state.allowIn;\n    startToken = lookahead;\n    state.allowIn = true;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    for (;;) {\n      if (match('.')) {\n        property = parseNonComputedMember();\n        expr = delegate.createMemberExpression('.', expr, property);\n      } else if (match('(')) {\n        args = parseArguments();\n        expr = delegate.createCallExpression(expr, args);\n      } else if (match('[')) {\n        property = parseComputedMember();\n        expr = delegate.createMemberExpression('[', expr, property);\n      } else {\n        break;\n      }\n\n      delegate.markEnd(expr, startToken);\n    }\n\n    state.allowIn = previousAllowIn;\n    return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n    var expr, property, startToken;\n    assert(state.allowIn, 'callee of new expression always allow in keyword.');\n    startToken = lookahead;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n    while (match('.') || match('[')) {\n      if (match('[')) {\n        property = parseComputedMember();\n        expr = delegate.createMemberExpression('[', expr, property);\n      } else {\n        property = parseNonComputedMember();\n        expr = delegate.createMemberExpression('.', expr, property);\n      }\n\n      delegate.markEnd(expr, startToken);\n    }\n\n    return expr;\n  } // 11.3 Postfix Expressions\n\n\n  function parsePostfixExpression() {\n    var expr,\n        token,\n        startToken = lookahead;\n    expr = parseLeftHandSideExpressionAllowCall();\n\n    if (lookahead.type === Token.Punctuator) {\n      if ((match('++') || match('--')) && !peekLineTerminator()) {\n        // 11.3.1, 11.3.2\n        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n          throwErrorTolerant({}, Messages.StrictLHSPostfix);\n        }\n\n        if (!isLeftHandSide(expr)) {\n          throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n        }\n\n        token = lex();\n        expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);\n      }\n    }\n\n    return expr;\n  } // 11.4 Unary Operators\n\n\n  function parseUnaryExpression() {\n    var token, expr, startToken;\n\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n      expr = parsePostfixExpression();\n    } else if (match('++') || match('--')) {\n      startToken = lookahead;\n      token = lex();\n      expr = parseUnaryExpression(); // 11.4.4, 11.4.5\n\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPrefix);\n      }\n\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      }\n\n      expr = delegate.createUnaryExpression(token.value, expr);\n      expr = delegate.markEnd(expr, startToken);\n    } else if (match('+') || match('-') || match('~') || match('!')) {\n      startToken = lookahead;\n      token = lex();\n      expr = parseUnaryExpression();\n      expr = delegate.createUnaryExpression(token.value, expr);\n      expr = delegate.markEnd(expr, startToken);\n    } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      startToken = lookahead;\n      token = lex();\n      expr = parseUnaryExpression();\n      expr = delegate.createUnaryExpression(token.value, expr);\n      expr = delegate.markEnd(expr, startToken);\n\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        throwErrorTolerant({}, Messages.StrictDelete);\n      }\n    } else {\n      expr = parsePostfixExpression();\n    }\n\n    return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n    var prec = 0;\n\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return 0;\n    }\n\n    switch (token.value) {\n      case '||':\n        prec = 1;\n        break;\n\n      case '&&':\n        prec = 2;\n        break;\n\n      case '|':\n        prec = 3;\n        break;\n\n      case '^':\n        prec = 4;\n        break;\n\n      case '&':\n        prec = 5;\n        break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        prec = 6;\n        break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n        prec = 7;\n        break;\n\n      case 'in':\n        prec = allowIn ? 7 : 0;\n        break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n        prec = 8;\n        break;\n\n      case '+':\n      case '-':\n        prec = 9;\n        break;\n\n      case '*':\n      case '/':\n      case '%':\n        prec = 11;\n        break;\n\n      default:\n        break;\n    }\n\n    return prec;\n  } // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n\n  function parseBinaryExpression() {\n    var marker, markers, expr, token, prec, stack, right, operator, left, i;\n    marker = lookahead;\n    left = parseUnaryExpression();\n    token = lookahead;\n    prec = binaryPrecedence(token, state.allowIn);\n\n    if (prec === 0) {\n      return left;\n    }\n\n    token.prec = prec;\n    lex();\n    markers = [marker, lookahead];\n    right = parseUnaryExpression();\n    stack = [left, token, right];\n\n    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        expr = delegate.createBinaryExpression(operator, left, right);\n        markers.pop();\n        marker = markers[markers.length - 1];\n        delegate.markEnd(expr, marker);\n        stack.push(expr);\n      } // Shift.\n\n\n      token = lex();\n      token.prec = prec;\n      stack.push(token);\n      markers.push(lookahead);\n      expr = parseUnaryExpression();\n      stack.push(expr);\n    } // Final reduce to clean-up the stack.\n\n\n    i = stack.length - 1;\n    expr = stack[i];\n    markers.pop();\n\n    while (i > 1) {\n      expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n      i -= 2;\n      marker = markers.pop();\n      delegate.markEnd(expr, marker);\n    }\n\n    return expr;\n  } // 11.12 Conditional Operator\n\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent, alternate, startToken;\n    startToken = lookahead;\n    expr = parseBinaryExpression();\n\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = parseAssignmentExpression();\n      state.allowIn = previousAllowIn;\n      expect(':');\n      alternate = parseAssignmentExpression();\n      expr = delegate.createConditionalExpression(expr, consequent, alternate);\n      delegate.markEnd(expr, startToken);\n    }\n\n    return expr;\n  } // 11.13 Assignment Operators\n\n\n  function parseAssignmentExpression() {\n    var token, left, right, node, startToken;\n    token = lookahead;\n    startToken = lookahead;\n    node = left = parseConditionalExpression();\n\n    if (matchAssign()) {\n      // LeftHandSideExpression\n      if (!isLeftHandSide(left)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      } // 11.13.1\n\n\n      if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\n        throwErrorTolerant(token, Messages.StrictLHSAssignment);\n      }\n\n      token = lex();\n      right = parseAssignmentExpression();\n      node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);\n    }\n\n    return node;\n  } // 11.14 Comma Operator\n\n\n  function parseExpression() {\n    var expr,\n        startToken = lookahead;\n    expr = parseAssignmentExpression();\n\n    if (match(',')) {\n      expr = delegate.createSequenceExpression([expr]);\n\n      while (index < length) {\n        if (!match(',')) {\n          break;\n        }\n\n        lex();\n        expr.expressions.push(parseAssignmentExpression());\n      }\n\n      delegate.markEnd(expr, startToken);\n    }\n\n    return expr;\n  } // 12.1 Block\n\n\n  function parseStatementList() {\n    var list = [],\n        statement;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      statement = parseSourceElement();\n\n      if (typeof statement === 'undefined') {\n        break;\n      }\n\n      list.push(statement);\n    }\n\n    return list;\n  }\n\n  function parseBlock() {\n    var block, startToken;\n    startToken = lookahead;\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return delegate.markEnd(delegate.createBlockStatement(block), startToken);\n  } // 12.2 Variable Statement\n\n\n  function parseVariableIdentifier() {\n    var token, startToken;\n    startToken = lookahead;\n    token = lex();\n\n    if (token.type !== Token.Identifier) {\n      throwUnexpected(token);\n    }\n\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n  }\n\n  function parseVariableDeclaration(kind) {\n    var init = null,\n        id,\n        startToken;\n    startToken = lookahead;\n    id = parseVariableIdentifier(); // 12.2.1\n\n    if (strict && isRestrictedWord(id.name)) {\n      throwErrorTolerant({}, Messages.StrictVarName);\n    }\n\n    if (kind === 'const') {\n      expect('=');\n      init = parseAssignmentExpression();\n    } else if (match('=')) {\n      lex();\n      init = parseAssignmentExpression();\n    }\n\n    return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);\n  }\n\n  function parseVariableDeclarationList(kind) {\n    var list = [];\n\n    do {\n      list.push(parseVariableDeclaration(kind));\n\n      if (!match(',')) {\n        break;\n      }\n\n      lex();\n    } while (index < length);\n\n    return list;\n  }\n\n  function parseVariableStatement() {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList();\n    consumeSemicolon();\n    return delegate.createVariableDeclaration(declarations, 'var');\n  } // kind may be `const` or `let`\n  // Both are experimental and not in the specification yet.\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n  // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n\n\n  function parseConstLetDeclaration(kind) {\n    var declarations, startToken;\n    startToken = lookahead;\n    expectKeyword(kind);\n    declarations = parseVariableDeclarationList(kind);\n    consumeSemicolon();\n    return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);\n  } // 12.3 Empty Statement\n\n\n  function parseEmptyStatement() {\n    expect(';');\n    return delegate.createEmptyStatement();\n  } // 12.4 Expression Statement\n\n\n  function parseExpressionStatement() {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return delegate.createExpressionStatement(expr);\n  } // 12.5 If statement\n\n\n  function parseIfStatement() {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n\n    return delegate.createIfStatement(test, consequent, alternate);\n  } // 12.6 Iteration Statements\n\n\n  function parseDoWhileStatement() {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n\n    if (match(';')) {\n      lex();\n    }\n\n    return delegate.createDoWhileStatement(body, test);\n  }\n\n  function parseWhileStatement() {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return delegate.createWhileStatement(test, body);\n  }\n\n  function parseForVariableDeclaration() {\n    var token, declarations, startToken;\n    startToken = lookahead;\n    token = lex();\n    declarations = parseVariableDeclarationList();\n    return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);\n  }\n\n  function parseForStatement() {\n    var init,\n        test,\n        update,\n        left,\n        right,\n        body,\n        oldInIteration,\n        previousAllowIn = state.allowIn;\n    init = test = update = null;\n    expectKeyword('for');\n    expect('(');\n\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var') || matchKeyword('let')) {\n        state.allowIn = false;\n        init = parseForVariableDeclaration();\n        state.allowIn = previousAllowIn;\n\n        if (init.declarations.length === 1 && matchKeyword('in')) {\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      } else {\n        state.allowIn = false;\n        init = parseExpression();\n        state.allowIn = previousAllowIn;\n\n        if (matchKeyword('in')) {\n          // LeftHandSideExpression\n          if (!isLeftHandSide(init)) {\n            throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n          }\n\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      }\n\n      if (typeof left === 'undefined') {\n        expect(';');\n      }\n    }\n\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n\n      expect(';');\n\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return typeof left === 'undefined' ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);\n  } // 12.7 The continue statement\n\n\n  function parseContinueStatement() {\n    var label = null,\n        key;\n    expectKeyword('continue'); // Optimize the most common form: 'continue;'.\n\n    if (source.charCodeAt(index) === 0x3B) {\n      lex();\n\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n\n      return delegate.createContinueStatement(null);\n    }\n\n    if (peekLineTerminator()) {\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n\n      return delegate.createContinueStatement(null);\n    }\n\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !state.inIteration) {\n      throwError({}, Messages.IllegalContinue);\n    }\n\n    return delegate.createContinueStatement(label);\n  } // 12.8 The break statement\n\n\n  function parseBreakStatement() {\n    var label = null,\n        key;\n    expectKeyword('break'); // Catch the very common case first: immediately a semicolon (U+003B).\n\n    if (source.charCodeAt(index) === 0x3B) {\n      lex();\n\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n\n      return delegate.createBreakStatement(null);\n    }\n\n    if (peekLineTerminator()) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n\n      return delegate.createBreakStatement(null);\n    }\n\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n\n    consumeSemicolon();\n\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError({}, Messages.IllegalBreak);\n    }\n\n    return delegate.createBreakStatement(label);\n  } // 12.9 The return statement\n\n\n  function parseReturnStatement() {\n    var argument = null;\n    expectKeyword('return');\n\n    if (!state.inFunctionBody) {\n      throwErrorTolerant({}, Messages.IllegalReturn);\n    } // 'return' followed by a space and an identifier is very common.\n\n\n    if (source.charCodeAt(index) === 0x20) {\n      if (isIdentifierStart(source.charCodeAt(index + 1))) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return delegate.createReturnStatement(argument);\n      }\n    }\n\n    if (peekLineTerminator()) {\n      return delegate.createReturnStatement(null);\n    }\n\n    if (!match(';')) {\n      if (!match('}') && lookahead.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n\n    consumeSemicolon();\n    return delegate.createReturnStatement(argument);\n  } // 12.10 The with statement\n\n\n  function parseWithStatement() {\n    var object, body;\n\n    if (strict) {\n      // TODO(ikarienator): Should we update the test cases instead?\n      skipComment();\n      throwErrorTolerant({}, Messages.StrictModeWith);\n    }\n\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return delegate.createWithStatement(object, body);\n  } // 12.10 The swith statement\n\n\n  function parseSwitchCase() {\n    var test,\n        consequent = [],\n        statement,\n        startToken;\n    startToken = lookahead;\n\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n\n    expect(':');\n\n    while (index < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n\n      statement = parseStatement();\n      consequent.push(statement);\n    }\n\n    return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);\n  }\n\n  function parseSwitchStatement() {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n\n    if (match('}')) {\n      lex();\n      return delegate.createSwitchStatement(discriminant, cases);\n    }\n\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      clause = parseSwitchCase();\n\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError({}, Messages.MultipleDefaultsInSwitch);\n        }\n\n        defaultFound = true;\n      }\n\n      cases.push(clause);\n    }\n\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return delegate.createSwitchStatement(discriminant, cases);\n  } // 12.13 The throw statement\n\n\n  function parseThrowStatement() {\n    var argument;\n    expectKeyword('throw');\n\n    if (peekLineTerminator()) {\n      throwError({}, Messages.NewlineAfterThrow);\n    }\n\n    argument = parseExpression();\n    consumeSemicolon();\n    return delegate.createThrowStatement(argument);\n  } // 12.14 The try statement\n\n\n  function parseCatchClause() {\n    var param, body, startToken;\n    startToken = lookahead;\n    expectKeyword('catch');\n    expect('(');\n\n    if (match(')')) {\n      throwUnexpected(lookahead);\n    }\n\n    param = parseVariableIdentifier(); // 12.14.1\n\n    if (strict && isRestrictedWord(param.name)) {\n      throwErrorTolerant({}, Messages.StrictCatchVariable);\n    }\n\n    expect(')');\n    body = parseBlock();\n    return delegate.markEnd(delegate.createCatchClause(param, body), startToken);\n  }\n\n  function parseTryStatement() {\n    var block,\n        handlers = [],\n        finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n\n    if (matchKeyword('catch')) {\n      handlers.push(parseCatchClause());\n    }\n\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n\n    if (handlers.length === 0 && !finalizer) {\n      throwError({}, Messages.NoCatchOrFinally);\n    }\n\n    return delegate.createTryStatement(block, [], handlers, finalizer);\n  } // 12.15 The debugger statement\n\n\n  function parseDebuggerStatement() {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return delegate.createDebuggerStatement();\n  } // 12 Statements\n\n\n  function parseStatement() {\n    var type = lookahead.type,\n        expr,\n        labeledBody,\n        key,\n        startToken;\n\n    if (type === Token.EOF) {\n      throwUnexpected(lookahead);\n    }\n\n    if (type === Token.Punctuator && lookahead.value === '{') {\n      return parseBlock();\n    }\n\n    startToken = lookahead;\n\n    if (type === Token.Punctuator) {\n      switch (lookahead.value) {\n        case ';':\n          return delegate.markEnd(parseEmptyStatement(), startToken);\n\n        case '(':\n          return delegate.markEnd(parseExpressionStatement(), startToken);\n\n        default:\n          break;\n      }\n    }\n\n    if (type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'break':\n          return delegate.markEnd(parseBreakStatement(), startToken);\n\n        case 'continue':\n          return delegate.markEnd(parseContinueStatement(), startToken);\n\n        case 'debugger':\n          return delegate.markEnd(parseDebuggerStatement(), startToken);\n\n        case 'do':\n          return delegate.markEnd(parseDoWhileStatement(), startToken);\n\n        case 'for':\n          return delegate.markEnd(parseForStatement(), startToken);\n\n        case 'function':\n          return delegate.markEnd(parseFunctionDeclaration(), startToken);\n\n        case 'if':\n          return delegate.markEnd(parseIfStatement(), startToken);\n\n        case 'return':\n          return delegate.markEnd(parseReturnStatement(), startToken);\n\n        case 'switch':\n          return delegate.markEnd(parseSwitchStatement(), startToken);\n\n        case 'throw':\n          return delegate.markEnd(parseThrowStatement(), startToken);\n\n        case 'try':\n          return delegate.markEnd(parseTryStatement(), startToken);\n\n        case 'var':\n          return delegate.markEnd(parseVariableStatement(), startToken);\n\n        case 'while':\n          return delegate.markEnd(parseWhileStatement(), startToken);\n\n        case 'with':\n          return delegate.markEnd(parseWithStatement(), startToken);\n\n        default:\n          break;\n      }\n    }\n\n    expr = parseExpression(); // 12.12 Labelled Statements\n\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n      key = '$' + expr.name;\n\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError({}, Messages.Redeclaration, 'Label', expr.name);\n      }\n\n      state.labelSet[key] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[key];\n      return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);\n    }\n\n    consumeSemicolon();\n    return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);\n  } // 13 Function Definition\n\n\n  function parseFunctionSourceElements() {\n    var sourceElement,\n        sourceElements = [],\n        token,\n        directive,\n        firstRestricted,\n        oldLabelSet,\n        oldInIteration,\n        oldInSwitch,\n        oldInFunctionBody,\n        startToken;\n    startToken = lookahead;\n    expect('{');\n\n    while (index < length) {\n      if (lookahead.type !== Token.StringLiteral) {\n        break;\n      }\n\n      token = lookahead;\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = source.slice(token.start + 1, token.end - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n\n      sourceElements.push(sourceElement);\n    }\n\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);\n  }\n\n  function parseParams(firstRestricted) {\n    var param,\n        params = [],\n        token,\n        stricted,\n        paramSet,\n        key,\n        message;\n    expect('(');\n\n    if (!match(')')) {\n      paramSet = {};\n\n      while (index < length) {\n        token = lookahead;\n        param = parseVariableIdentifier();\n        key = '$' + token.value;\n\n        if (strict) {\n          if (isRestrictedWord(token.value)) {\n            stricted = token;\n            message = Messages.StrictParamName;\n          }\n\n          if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n            stricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        } else if (!firstRestricted) {\n          if (isRestrictedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamName;\n          } else if (isStrictModeReservedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictReservedWord;\n          } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n            firstRestricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        }\n\n        params.push(param);\n        paramSet[key] = true;\n\n        if (match(')')) {\n          break;\n        }\n\n        expect(',');\n      }\n    }\n\n    expect(')');\n    return {\n      params: params,\n      stricted: stricted,\n      firstRestricted: firstRestricted,\n      message: message\n    };\n  }\n\n  function parseFunctionDeclaration() {\n    var id,\n        params = [],\n        body,\n        token,\n        stricted,\n        tmp,\n        firstRestricted,\n        message,\n        previousStrict,\n        startToken;\n    startToken = lookahead;\n    expectKeyword('function');\n    token = lookahead;\n    id = parseVariableIdentifier();\n\n    if (strict) {\n      if (isRestrictedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictFunctionName);\n      }\n    } else {\n      if (isRestrictedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictFunctionName;\n      } else if (isStrictModeReservedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictReservedWord;\n      }\n    }\n\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n\n    if (tmp.message) {\n      message = tmp.message;\n    }\n\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n\n    strict = previousStrict;\n    return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);\n  }\n\n  function parseFunctionExpression() {\n    var token,\n        id = null,\n        stricted,\n        firstRestricted,\n        message,\n        tmp,\n        params = [],\n        body,\n        previousStrict,\n        startToken;\n    startToken = lookahead;\n    expectKeyword('function');\n\n    if (!match('(')) {\n      token = lookahead;\n      id = parseVariableIdentifier();\n\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          throwErrorTolerant(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n\n    if (tmp.message) {\n      message = tmp.message;\n    }\n\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n\n    strict = previousStrict;\n    return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);\n  } // 14 Program\n\n\n  function parseSourceElement() {\n    if (lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'const':\n        case 'let':\n          return parseConstLetDeclaration(lookahead.value);\n\n        case 'function':\n          return parseFunctionDeclaration();\n\n        default:\n          return parseStatement();\n      }\n    }\n\n    if (lookahead.type !== Token.EOF) {\n      return parseStatement();\n    }\n  }\n\n  function parseSourceElements() {\n    var sourceElement,\n        sourceElements = [],\n        token,\n        directive,\n        firstRestricted;\n\n    while (index < length) {\n      token = lookahead;\n\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n\n      directive = source.slice(token.start + 1, token.end - 1);\n\n      if (directive === 'use strict') {\n        strict = true;\n\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n\n    while (index < length) {\n      sourceElement = parseSourceElement();\n      /* istanbul ignore if */\n\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n\n      sourceElements.push(sourceElement);\n    }\n\n    return sourceElements;\n  }\n\n  function parseProgram() {\n    var body, startToken;\n    skipComment();\n    peek();\n    startToken = lookahead;\n    strict = false;\n    body = parseSourceElements();\n    return delegate.markEnd(delegate.createProgram(body), startToken);\n  }\n\n  function filterTokenLocation() {\n    var i,\n        entry,\n        token,\n        tokens = [];\n\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n\n      if (extra.range) {\n        token.range = entry.range;\n      }\n\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n\n      tokens.push(token);\n    }\n\n    extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n    var toString, token, tokens;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    delegate = SyntaxTreeDelegate;\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1\n    };\n    extra = {}; // Options matching.\n\n    options = options || {}; // Of course we collect tokens here.\n\n    options.tokens = true;\n    extra.tokens = [];\n    extra.tokenize = true; // The following two fields are necessary to compute the Regex tokens.\n\n    extra.openParenToken = -1;\n    extra.openCurlyToken = -1;\n    extra.range = typeof options.range === 'boolean' && options.range;\n    extra.loc = typeof options.loc === 'boolean' && options.loc;\n\n    if (typeof options.comment === 'boolean' && options.comment) {\n      extra.comments = [];\n    }\n\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\n      extra.errors = [];\n    }\n\n    try {\n      peek();\n\n      if (lookahead.type === Token.EOF) {\n        return extra.tokens;\n      }\n\n      token = lex();\n\n      while (lookahead.type !== Token.EOF) {\n        try {\n          token = lex();\n        } catch (lexError) {\n          token = lookahead;\n\n          if (extra.errors) {\n            extra.errors.push(lexError); // We have to break on the first error\n            // to avoid infinite loops.\n\n            break;\n          } else {\n            throw lexError;\n          }\n        }\n      }\n\n      filterTokenLocation();\n      tokens = extra.tokens;\n\n      if (typeof extra.comments !== 'undefined') {\n        tokens.comments = extra.comments;\n      }\n\n      if (typeof extra.errors !== 'undefined') {\n        tokens.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n\n    return tokens;\n  }\n\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n\n    delegate = SyntaxTreeDelegate;\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1\n    };\n    extra = {};\n\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n\n      if (extra.loc && options.source !== null && options.source !== undefined) {\n        extra.source = toString(options.source);\n      }\n\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n\n      if (extra.attachComment) {\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n      }\n    }\n\n    try {\n      program = parseProgram();\n\n      if (typeof extra.comments !== 'undefined') {\n        program.comments = extra.comments;\n      }\n\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n\n    return program;\n  } // Sync with *.json manifests.\n\n\n  exports.version = '1.2.5';\n  exports.tokenize = tokenize;\n  exports.parse = parse; // Deep copy.\n\n  /* istanbul ignore next */\n\n  exports.Syntax = function () {\n    var name,\n        types = {};\n\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["/Users/leena/Downloads/MyProjectDemo/Udacity_Data_Science_Nanodegree_Repo/COVID_India/react_project/react_project/node_modules/cwise-parser/node_modules/esprima/esprima.js"],"names":["root","factory","define","amd","exports","esprima","Token","TokenName","FnExprTokens","Syntax","PropertyKind","Messages","Regex","SyntaxTreeDelegate","source","strict","index","lineNumber","lineStart","length","delegate","lookahead","state","extra","BooleanLiteral","EOF","Identifier","Keyword","NullLiteral","NumericLiteral","Punctuator","StringLiteral","RegularExpression","AssignmentExpression","ArrayExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","NewExpression","ObjectExpression","Program","Property","ReturnStatement","SequenceExpression","SwitchStatement","SwitchCase","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","Data","Get","Set","UnexpectedToken","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","UnexpectedEOS","NewlineAfterThrow","InvalidRegExp","UnterminatedRegExp","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictOctalLiteral","StrictDelete","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","StrictReservedWord","NonAsciiIdentifierStart","RegExp","NonAsciiIdentifierPart","assert","condition","message","Error","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","test","String","fromCharCode","isIdentifierPart","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","isKeyword","addComment","type","value","start","end","loc","comment","attacher","lastCommentStart","range","comments","push","attachComment","leadingComments","trailingComments","skipSingleLineComment","offset","line","column","charCodeAt","slice","skipMultiLineComment","throwError","skipComment","scanHexEscape","prefix","i","len","code","toLowerCase","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","scanPunctuator","code2","ch1","ch2","ch3","ch4","tokenize","openParenToken","tokens","openCurlyToken","scanHexLiteral","number","parseInt","scanOctalLiteral","octal","isImplicitOctalLiteral","scanNumericLiteral","parseFloat","scanStringLiteral","str","quote","unescaped","restore","startLineNumber","startLineStart","testRegExp","pattern","flags","e","scanRegExpBody","classMarker","terminated","body","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","collectRegex","pos","regex","token","pop","isIdentifierName","advanceSlash","prevToken","checkToken","advance","collectToken","lex","peek","Position","SourceLocation","startLine","startColumn","name","processComment","node","lastChild","bottomRightStack","markEnd","startToken","undefined","postProcess","createArrayExpression","elements","createAssignmentExpression","operator","left","right","createBinaryExpression","createBlockStatement","createBreakStatement","label","createCallExpression","callee","args","createCatchClause","param","createConditionalExpression","consequent","alternate","createContinueStatement","createDebuggerStatement","createDoWhileStatement","createEmptyStatement","createExpressionStatement","expression","createForStatement","init","update","createForInStatement","each","createFunctionDeclaration","params","defaults","rest","generator","createFunctionExpression","createIdentifier","createIfStatement","createLabeledStatement","createLiteral","raw","createMemberExpression","accessor","object","property","computed","createNewExpression","createObjectExpression","properties","createPostfixExpression","argument","createProgram","createProperty","kind","key","createReturnStatement","createSequenceExpression","expressions","createSwitchCase","createSwitchStatement","discriminant","cases","createThisExpression","createThrowStatement","createTryStatement","block","guardedHandlers","handlers","finalizer","createUnaryExpression","createVariableDeclaration","declarations","createVariableDeclarator","createWhileStatement","createWithStatement","peekLineTerminator","found","messageFormat","error","Array","prototype","call","arguments","msg","replace","whole","description","apply","errors","throwUnexpected","expect","expectKeyword","keyword","match","matchKeyword","matchAssign","op","consumeSemicolon","oldIndex","oldLineNumber","oldLineStart","oldLookahead","isLeftHandSide","expr","parseArrayInitialiser","parseAssignmentExpression","parsePropertyFunction","first","previousStrict","parseFunctionSourceElements","parseObjectPropertyKey","parseObjectProperty","parseVariableIdentifier","parseObjectInitialiser","map","toString","Object","hasOwnProperty","parseGroupExpression","parseExpression","parsePrimaryExpression","parseFunctionExpression","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseNewExpression","parseLeftHandSideExpression","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","parsePostfixExpression","parseUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","parseConditionalExpression","parseStatementList","list","statement","parseSourceElement","parseBlock","parseVariableDeclaration","parseVariableDeclarationList","parseVariableStatement","parseConstLetDeclaration","parseEmptyStatement","parseExpressionStatement","parseIfStatement","parseStatement","parseDoWhileStatement","oldInIteration","inIteration","parseWhileStatement","parseForVariableDeclaration","parseForStatement","parseContinueStatement","labelSet","parseBreakStatement","inSwitch","parseReturnStatement","inFunctionBody","parseWithStatement","parseSwitchCase","parseSwitchStatement","clause","oldInSwitch","defaultFound","parseThrowStatement","parseCatchClause","parseTryStatement","parseDebuggerStatement","labeledBody","parseFunctionDeclaration","sourceElement","sourceElements","directive","firstRestricted","oldLabelSet","oldInFunctionBody","parseParams","stricted","paramSet","tmp","parseSourceElements","parseProgram","filterTokenLocation","entry","options","tolerant","lexError","parse","program","version","types","create","freeze"],"mappings":"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","sourcesContent":["/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowErrorTolerant: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseUnaryExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment, attacher;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function skipComment() {\n        var ch, start;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 0x2E:  // . dot\n        case 0x28:  // ( open bracket\n        case 0x29:  // ) close bracket\n        case 0x3B:  // ; semicolon\n        case 0x2C:  // , comma\n        case 0x7B:  // { open curly brace\n        case 0x7D:  // } close curly brace\n        case 0x5B:  // [\n        case 0x5D:  // ]\n        case 0x3A:  // :\n        case 0x3F:  // ?\n        case 0x7E:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 0x28) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 0x7B) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (U+003D) marks an assignment or comparison operator.\n            if (code2 === 0x3D) {\n                switch (code) {\n                case 0x2B:  // +\n                case 0x2D:  // -\n                case 0x2F:  // /\n                case 0x3C:  // <\n                case 0x3E:  // >\n                case 0x5E:  // ^\n                case 0x7C:  // |\n                case 0x25:  // %\n                case 0x26:  // &\n                case 0x2A:  // *\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n\n                case 0x21: // !\n                case 0x3D: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 0x3D) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n                }\n            }\n        }\n\n        // 4-character punctuator: >>>=\n\n        ch4 = source.substr(index, 4);\n\n        if (ch4 === '>>>=') {\n            index += 4;\n            return {\n                type: Token.Punctuator,\n                value: ch4,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        ch3 = ch4.substr(0, 3);\n\n        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: ch3,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n        ch2 = ch3.substr(0, 2);\n\n        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 1-character punctuators: < > = ! + - * % & | ^ /\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(start) {\n        var number = '0' + source[index++];\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: true,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            startLineNumber: startLineNumber,\n            startLineStart: startLineStart,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var value;\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n        return value;\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                } else {\n                    str += '\\\\';\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, pattern, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ']') {\n                return scanPunctuator();\n            }\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, range, value;\n\n        skipComment();\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function Position(line, column) {\n        this.line = line;\n        this.column = column;\n    }\n\n    function SourceLocation(startLine, startColumn, line, column) {\n        this.start = new Position(startLine, startColumn);\n        this.end = new Position(line, column);\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        processComment: function (node) {\n            var lastChild, trailingComments;\n\n            if (node.type === Syntax.Program) {\n                if (node.body.length > 0) {\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                if (extra.trailingComments[0].range[0] >= node.range[1]) {\n                    trailingComments = extra.trailingComments;\n                    extra.trailingComments = [];\n                } else {\n                    extra.trailingComments.length = 0;\n                }\n            } else {\n                if (extra.bottomRightStack.length > 0 &&\n                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&\n                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {\n                    trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n                    delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {\n                lastChild = extra.bottomRightStack.pop();\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n                    node.leadingComments = lastChild.leadingComments;\n                    delete lastChild.leadingComments;\n                }\n            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n                node.leadingComments = extra.leadingComments;\n                extra.leadingComments = [];\n            }\n\n\n            if (trailingComments) {\n                node.trailingComments = trailingComments;\n            }\n\n            extra.bottomRightStack.push(node);\n        },\n\n        markEnd: function (node, startToken) {\n            if (extra.range) {\n                node.range = [startToken.start, index];\n            }\n            if (extra.loc) {\n                node.loc = new SourceLocation(\n                    startToken.startLineNumber === undefined ?  startToken.lineNumber : startToken.startLineNumber,\n                    startToken.start - (startToken.startLineStart === undefined ?  startToken.lineStart : startToken.startLineStart),\n                    lineNumber,\n                    index - lineStart\n                );\n                this.postProcess(node);\n            }\n\n            if (extra.attachComment) {\n                this.processComment(node);\n            }\n            return node;\n        },\n\n        postProcess: function (node) {\n            if (extra.source) {\n                node.loc.source = extra.source;\n            }\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createFunctionExpression: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            return {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.start, token.end)\n            };\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        }\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.start;\n            error.lineNumber = token.lineNumber;\n            error.column = token.start - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line, oldIndex = index, oldLineNumber = lineNumber,\n            oldLineStart = lineStart, oldLookahead = lookahead;\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            index = oldIndex;\n            lineNumber = oldLineNumber;\n            lineStart = oldLineStart;\n            lookahead = oldLookahead;\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], startToken;\n\n        startToken = lookahead;\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body, startToken;\n\n        previousStrict = strict;\n        startToken = lookahead;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);\n    }\n\n    function parseObjectPropertyKey() {\n        var token, startToken;\n\n        startToken = lookahead;\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return delegate.markEnd(delegate.createLiteral(token), startToken);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param, startToken;\n\n        token = lookahead;\n        startToken = lookahead;\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction([]);\n                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);\n            }\n            if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    value = parsePropertyFunction([]);\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    value = parsePropertyFunction(param, token);\n                }\n                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);\n            }\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', id, value), startToken);\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', key, value), startToken);\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;\n\n        startToken = lookahead;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, startToken;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        type = lookahead.type;\n        startToken = lookahead;\n\n        if (type === Token.Identifier) {\n            expr =  delegate.createIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = delegate.createLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                expr = delegate.createThisExpression();\n            } else {\n                throwUnexpected(lex());\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = delegate.createLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = delegate.createLiteral(token);\n        } else if (match('/') || match('/=')) {\n            if (typeof extra.tokens !== 'undefined') {\n                expr = delegate.createLiteral(collectRegex());\n            } else {\n                expr = delegate.createLiteral(scanRegExp());\n            }\n            peek();\n        } else {\n            throwUnexpected(lex());\n        }\n\n        return delegate.markEnd(expr, startToken);\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, startToken;\n\n        startToken = lookahead;\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, startToken;\n\n        startToken = lookahead;\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        for (;;) {\n            if (match('.')) {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n            } else if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                break;\n            }\n            delegate.markEnd(expr, startToken);\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            delegate.markEnd(expr, startToken);\n        }\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = parseLeftHandSideExpressionAllowCall();\n\n        if (lookahead.type === Token.Punctuator) {\n            if ((match('++') || match('--')) && !peekLineTerminator()) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    throwErrorTolerant({}, Messages.StrictLHSPostfix);\n                }\n\n                if (!isLeftHandSide(expr)) {\n                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n                }\n\n                token = lex();\n                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = delegate.createUnaryExpression(token.value, expr);\n            expr = delegate.markEnd(expr, startToken);\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            expr = delegate.markEnd(expr, startToken);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            expr = delegate.markEnd(expr, startToken);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers[markers.length - 1];\n                delegate.markEnd(expr, marker);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            delegate.markEnd(expr, marker);\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = delegate.createConditionalExpression(expr, consequent, alternate);\n            delegate.markEnd(expr, startToken);\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, left, right, node, startToken;\n\n        token = lookahead;\n        startToken = lookahead;\n\n        node = left = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(left)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            token = lex();\n            right = parseAssignmentExpression();\n            node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);\n        }\n\n        return node;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead;\n\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = delegate.createSequenceExpression([ expr ]);\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n\n            delegate.markEnd(expr, startToken);\n        }\n\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, startToken;\n\n        startToken = lookahead;\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return delegate.markEnd(delegate.createBlockStatement(block), startToken);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token, startToken;\n\n        startToken = lookahead;\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n    }\n\n    function parseVariableDeclaration(kind) {\n        var init = null, id, startToken;\n\n        startToken = lookahead;\n        id = parseVariableIdentifier();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return delegate.createVariableDeclaration(declarations, 'var');\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations, startToken;\n\n        startToken = lookahead;\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n        return delegate.createEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return delegate.createExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return delegate.createIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return delegate.createDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return delegate.createWhileStatement(test, body);\n    }\n\n    function parseForVariableDeclaration() {\n        var token, declarations, startToken;\n\n        startToken = lookahead;\n        token = lex();\n        declarations = parseVariableDeclarationList();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = previousAllowIn;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                delegate.createForStatement(init, test, update, body) :\n                delegate.createForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return delegate.createContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return delegate.createBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return delegate.createReturnStatement(argument);\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return delegate.createReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return delegate.createReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            // TODO(ikarienator): Should we update the test cases instead?\n            skipComment();\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return delegate.createWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, startToken;\n\n        startToken = lookahead;\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            consequent.push(statement);\n        }\n\n        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return delegate.createSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return delegate.createSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return delegate.createThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, startToken;\n\n        startToken = lookahead;\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return delegate.createTryStatement(block, [], handlers, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return delegate.createDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            startToken;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n\n        startToken = lookahead;\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return delegate.markEnd(parseEmptyStatement(), startToken);\n            case '(':\n                return delegate.markEnd(parseExpressionStatement(), startToken);\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return delegate.markEnd(parseBreakStatement(), startToken);\n            case 'continue':\n                return delegate.markEnd(parseContinueStatement(), startToken);\n            case 'debugger':\n                return delegate.markEnd(parseDebuggerStatement(), startToken);\n            case 'do':\n                return delegate.markEnd(parseDoWhileStatement(), startToken);\n            case 'for':\n                return delegate.markEnd(parseForStatement(), startToken);\n            case 'function':\n                return delegate.markEnd(parseFunctionDeclaration(), startToken);\n            case 'if':\n                return delegate.markEnd(parseIfStatement(), startToken);\n            case 'return':\n                return delegate.markEnd(parseReturnStatement(), startToken);\n            case 'switch':\n                return delegate.markEnd(parseSwitchStatement(), startToken);\n            case 'throw':\n                return delegate.markEnd(parseThrowStatement(), startToken);\n            case 'try':\n                return delegate.markEnd(parseTryStatement(), startToken);\n            case 'var':\n                return delegate.markEnd(parseVariableStatement(), startToken);\n            case 'while':\n                return delegate.markEnd(parseWhileStatement(), startToken);\n            case 'with':\n                return delegate.markEnd(parseWithStatement(), startToken);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);\n        }\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;\n\n        startToken = lookahead;\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);\n    }\n\n    function parseParams(firstRestricted) {\n        var param, params = [], token, stricted, paramSet, key, message;\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead;\n                param = parseVariableIdentifier();\n                key = '$' + token.value;\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[key] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return {\n            params: params,\n            stricted: stricted,\n            firstRestricted: firstRestricted,\n            message: message\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;\n\n        startToken = lookahead;\n\n        expectKeyword('function');\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;\n\n        startToken = lookahead;\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            /* istanbul ignore if */\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body, startToken;\n\n        skipComment();\n        peek();\n        startToken = lookahead;\n        strict = false;\n\n        body = parseSourceElements();\n        return delegate.markEnd(delegate.createProgram(body), startToken);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '1.2.5';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n   /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]},"metadata":{},"sourceType":"script"}