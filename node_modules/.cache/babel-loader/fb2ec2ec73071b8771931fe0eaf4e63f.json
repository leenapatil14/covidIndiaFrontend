{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing'); // constants for dynamic jitter (ie less jitter for sparser points)\n\n\nvar JITTERCOUNT = 5; // points either side of this to include\n\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(boxLayer, cdbox, 'trace boxes').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace; // whisker width\n\n    t.wdPos = t.bdPos * trace.whiskerwidth;\n\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n\n    var posAxis, valAxis;\n\n    if (trace.orientation === 'h') {\n      posAxis = ya;\n      valAxis = xa;\n    } else {\n      posAxis = xa;\n      valAxis = ya;\n    }\n\n    plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t);\n    plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n    plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, t);\n  });\n}\n\nfunction plotBoxAndWhiskers(sel, axes, trace, t) {\n  var posAxis = axes.pos;\n  var valAxis = axes.val;\n  var bPos = t.bPos;\n  var wdPos = t.wdPos || 0;\n  var bPosPxOffset = t.bPosPxOffset || 0;\n  var whiskerWidth = trace.whiskerwidth || 0;\n  var notched = trace.notched || false;\n  var nw = notched ? 1 - 2 * trace.notchwidth : 1; // to support for one-sided box\n\n  var bdPos0;\n  var bdPos1;\n\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n\n  var paths = sel.selectAll('path.box').data(trace.type !== 'violin' || trace.box.visible ? Lib.identity : []);\n  paths.enter().append('path').style('vector-effect', 'non-scaling-stroke').attr('class', 'box');\n  paths.exit().remove();\n  paths.each(function (d) {\n    if (d.empty) return 'M0,0Z';\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var posc = posAxis.l2p(lcenter) + bPosPxOffset;\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var posw0 = posAxis.l2p(lcenter - wdPos) + bPosPxOffset;\n    var posw1 = posAxis.l2p(lcenter + wdPos) + bPosPxOffset;\n    var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;\n    var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;\n    var q1 = valAxis.c2p(d.q1, true);\n    var q3 = valAxis.c2p(d.q3, true); // make sure median isn't identical to either of the\n    // quartiles, so we can see it\n\n    var m = Lib.constrain(valAxis.c2p(d.med, true), Math.min(q1, q3) + 1, Math.max(q1, q3) - 1); // for compatibility with box, violin, and candlestick\n    // perhaps we should put this into cd0.t instead so it's more explicit,\n    // but what we have now is:\n    // - box always has d.lf, but boxpoints can be anything\n    // - violin has d.lf and should always use it (boxpoints is undefined)\n    // - candlestick has only min/max\n\n    var useExtremes = d.lf === undefined || trace.boxpoints === false;\n    var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n    var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n    var ln = valAxis.c2p(d.ln, true);\n    var un = valAxis.c2p(d.un, true);\n\n    if (trace.orientation === 'h') {\n      d3.select(this).attr('d', 'M' + m + ',' + posm0 + 'V' + posm1 + // median line\n      'M' + q1 + ',' + pos0 + 'V' + pos1 + ( // left edge\n      notched ? 'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 : '') + // top notched edge\n      'H' + q3 + // end of the top edge\n      'V' + pos0 + ( // right edge\n      notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') + // bottom notched edge\n      'Z' + // end of the box\n      'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + ( // whiskers\n      whiskerWidth === 0 ? '' : // whisker caps\n      'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1));\n    } else {\n      d3.select(this).attr('d', 'M' + posm0 + ',' + m + 'H' + posm1 + // median line\n      'M' + pos0 + ',' + q1 + 'H' + pos1 + ( // top of the box\n      notched ? 'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un : '') + // notched right edge\n      'V' + q3 + // end of the right edge\n      'H' + pos0 + ( // bottom of the box\n      notched ? 'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln : '') + // notched left edge\n      'Z' + // end of the box\n      'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + ( // whiskers\n      whiskerWidth === 0 ? '' : // whisker caps\n      'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1));\n    }\n  });\n}\n\nfunction plotPoints(sel, axes, trace, t) {\n  var xa = axes.x;\n  var ya = axes.y;\n  var bdPos = t.bdPos;\n  var bPos = t.bPos; // to support violin points\n\n  var mode = trace.boxpoints || trace.points; // repeatable pseudo-random number generator\n\n  Lib.seedPseudoRandom(); // since box plot points get an extra level of nesting, each\n  // box needs the trace styling info\n\n  var fn = function (d) {\n    d.forEach(function (v) {\n      v.t = t;\n      v.trace = trace;\n    });\n    return d;\n  };\n\n  var gPoints = sel.selectAll('g.points').data(mode ? fn : []);\n  gPoints.enter().append('g').attr('class', 'points');\n  gPoints.exit().remove();\n  var paths = gPoints.selectAll('path').data(function (d) {\n    var i;\n    var pts = d.pts2; // normally use IQR, but if this is 0 or too small, use max-min\n\n    var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n    var minSpread = typicalSpread * 1e-9;\n    var spreadLimit = typicalSpread * JITTERSPREAD;\n    var jitterFactors = [];\n    var maxJitterFactor = 0;\n    var newJitter; // dynamic jitter\n\n    if (trace.jitter) {\n      if (typicalSpread === 0) {\n        // edge case of no spread at all: fall back to max jitter\n        maxJitterFactor = 1;\n        jitterFactors = new Array(pts.length);\n\n        for (i = 0; i < pts.length; i++) {\n          jitterFactors[i] = 1;\n        }\n      } else {\n        for (i = 0; i < pts.length; i++) {\n          var i0 = Math.max(0, i - JITTERCOUNT);\n          var pmin = pts[i0].v;\n          var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n          var pmax = pts[i1].v;\n\n          if (mode !== 'all') {\n            if (pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);else pmin = Math.max(pmin, d.uf);\n          }\n\n          var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n          jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n          jitterFactors.push(jitterFactor);\n          maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n        }\n      }\n\n      newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n    } // fills in 'x' and 'y' in calcdata 'pts' item\n\n\n    for (i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var v = pt.v;\n      var jitterOffset = trace.jitter ? newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5) : 0;\n      var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n\n      if (trace.orientation === 'h') {\n        pt.y = posPx;\n        pt.x = v;\n      } else {\n        pt.x = posPx;\n        pt.y = v;\n      } // tag suspected outliers\n\n\n      if (mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n        pt.so = true;\n      }\n    }\n\n    return pts;\n  });\n  paths.enter().append('path').classed('point', true);\n  paths.exit().remove();\n  paths.call(Drawing.translatePoints, xa, ya);\n}\n\nfunction plotBoxMean(sel, axes, trace, t) {\n  var posAxis = axes.pos;\n  var valAxis = axes.val;\n  var bPos = t.bPos;\n  var bPosPxOffset = t.bPosPxOffset || 0; // to support violin mean lines\n\n  var mode = trace.boxmean || (trace.meanline || {}).visible; // to support for one-sided box\n\n  var bdPos0;\n  var bdPos1;\n\n  if (Array.isArray(t.bdPos)) {\n    bdPos0 = t.bdPos[0];\n    bdPos1 = t.bdPos[1];\n  } else {\n    bdPos0 = t.bdPos;\n    bdPos1 = t.bdPos;\n  }\n\n  var paths = sel.selectAll('path.mean').data(trace.type === 'box' && trace.boxmean || trace.type === 'violin' && trace.box.visible && trace.meanline.visible ? Lib.identity : []);\n  paths.enter().append('path').attr('class', 'mean').style({\n    fill: 'none',\n    'vector-effect': 'non-scaling-stroke'\n  });\n  paths.exit().remove();\n  paths.each(function (d) {\n    var lcenter = posAxis.c2l(d.pos + bPos, true);\n    var posc = posAxis.l2p(lcenter) + bPosPxOffset;\n    var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n    var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n    var m = valAxis.c2p(d.mean, true);\n    var sl = valAxis.c2p(d.mean - d.sd, true);\n    var sh = valAxis.c2p(d.mean + d.sd, true);\n\n    if (trace.orientation === 'h') {\n      d3.select(this).attr('d', 'M' + m + ',' + pos0 + 'V' + pos1 + (mode === 'sd' ? 'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' : ''));\n    } else {\n      d3.select(this).attr('d', 'M' + pos0 + ',' + m + 'H' + pos1 + (mode === 'sd' ? 'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' : ''));\n    }\n  });\n}\n\nmodule.exports = {\n  plot: plot,\n  plotBoxAndWhiskers: plotBoxAndWhiskers,\n  plotPoints: plotPoints,\n  plotBoxMean: plotBoxMean\n};","map":{"version":3,"sources":["/Users/leena/Downloads/MyProjectDemo/covidIndia/node_modules/plotly.js/src/traces/box/plot.js"],"names":["d3","require","Lib","Drawing","JITTERCOUNT","JITTERSPREAD","plot","gd","plotinfo","cdbox","boxLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","plotGroup","select","cd0","t","trace","wdPos","bdPos","whiskerwidth","visible","empty","remove","posAxis","valAxis","orientation","plotBoxAndWhiskers","pos","val","plotPoints","x","y","plotBoxMean","sel","axes","bPos","bPosPxOffset","whiskerWidth","notched","nw","notchwidth","bdPos0","bdPos1","Array","isArray","paths","selectAll","data","type","box","identity","enter","append","style","attr","exit","d","lcenter","c2l","posc","l2p","pos0","pos1","posw0","posw1","posm0","posm1","q1","c2p","q3","m","constrain","med","Math","min","max","useExtremes","lf","undefined","boxpoints","uf","ln","un","mode","points","seedPseudoRandom","fn","forEach","v","gPoints","i","pts","pts2","typicalSpread","minSpread","spreadLimit","jitterFactors","maxJitterFactor","newJitter","jitter","length","i0","pmin","i1","pmax","jitterFactor","sqrt","abs","push","pt","jitterOffset","pseudoRandom","posPx","pointpos","uo","lo","so","classed","call","translatePoints","boxmean","meanline","fill","mean","sl","sd","sh","module","exports"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\n// constants for dynamic jitter (ie less jitter for sparser points)\nvar JITTERCOUNT = 5; // points either side of this to include\nvar JITTERSPREAD = 0.01; // fraction of IQR to count as \"dense\"\n\nfunction plot(gd, plotinfo, cdbox, boxLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(boxLayer, cdbox, 'trace boxes').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n\n        // whisker width\n        t.wdPos = t.bdPos * trace.whiskerwidth;\n\n        if(trace.visible !== true || t.empty) {\n            plotGroup.remove();\n            return;\n        }\n\n        var posAxis, valAxis;\n\n        if(trace.orientation === 'h') {\n            posAxis = ya;\n            valAxis = xa;\n        } else {\n            posAxis = xa;\n            valAxis = ya;\n        }\n\n        plotBoxAndWhiskers(plotGroup, {pos: posAxis, val: valAxis}, trace, t);\n        plotPoints(plotGroup, {x: xa, y: ya}, trace, t);\n        plotBoxMean(plotGroup, {pos: posAxis, val: valAxis}, trace, t);\n    });\n}\n\nfunction plotBoxAndWhiskers(sel, axes, trace, t) {\n    var posAxis = axes.pos;\n    var valAxis = axes.val;\n    var bPos = t.bPos;\n    var wdPos = t.wdPos || 0;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n    var whiskerWidth = trace.whiskerwidth || 0;\n    var notched = trace.notched || false;\n    var nw = notched ? 1 - 2 * trace.notchwidth : 1;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.box').data((\n        trace.type !== 'violin' ||\n        trace.box.visible\n    ) ? Lib.identity : []);\n\n    paths.enter().append('path')\n        .style('vector-effect', 'non-scaling-stroke')\n        .attr('class', 'box');\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        if(d.empty) return 'M0,0Z';\n\n        var lcenter = posAxis.c2l(d.pos + bPos, true);\n        var posc = posAxis.l2p(lcenter) + bPosPxOffset;\n        var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n        var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n        var posw0 = posAxis.l2p(lcenter - wdPos) + bPosPxOffset;\n        var posw1 = posAxis.l2p(lcenter + wdPos) + bPosPxOffset;\n        var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;\n        var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;\n        var q1 = valAxis.c2p(d.q1, true);\n        var q3 = valAxis.c2p(d.q3, true);\n        // make sure median isn't identical to either of the\n        // quartiles, so we can see it\n        var m = Lib.constrain(\n            valAxis.c2p(d.med, true),\n            Math.min(q1, q3) + 1, Math.max(q1, q3) - 1\n        );\n\n        // for compatibility with box, violin, and candlestick\n        // perhaps we should put this into cd0.t instead so it's more explicit,\n        // but what we have now is:\n        // - box always has d.lf, but boxpoints can be anything\n        // - violin has d.lf and should always use it (boxpoints is undefined)\n        // - candlestick has only min/max\n        var useExtremes = (d.lf === undefined) || (trace.boxpoints === false);\n        var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);\n        var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);\n        var ln = valAxis.c2p(d.ln, true);\n        var un = valAxis.c2p(d.un, true);\n\n        if(trace.orientation === 'h') {\n            d3.select(this).attr('d',\n                'M' + m + ',' + posm0 + 'V' + posm1 + // median line\n                'M' + q1 + ',' + pos0 + 'V' + pos1 + // left edge\n                (notched ? 'H' + ln + 'L' + m + ',' + posm1 + 'L' + un + ',' + pos1 : '') + // top notched edge\n                'H' + q3 + // end of the top edge\n                'V' + pos0 + // right edge\n                (notched ? 'H' + un + 'L' + m + ',' + posm0 + 'L' + ln + ',' + pos0 : '') + // bottom notched edge\n                'Z' + // end of the box\n                'M' + q1 + ',' + posc + 'H' + lf + 'M' + q3 + ',' + posc + 'H' + uf + // whiskers\n                ((whiskerWidth === 0) ? '' : // whisker caps\n                    'M' + lf + ',' + posw0 + 'V' + posw1 + 'M' + uf + ',' + posw0 + 'V' + posw1));\n        } else {\n            d3.select(this).attr('d',\n                'M' + posm0 + ',' + m + 'H' + posm1 + // median line\n                'M' + pos0 + ',' + q1 + 'H' + pos1 + // top of the box\n                (notched ? 'V' + ln + 'L' + posm1 + ',' + m + 'L' + pos1 + ',' + un : '') + // notched right edge\n                'V' + q3 + // end of the right edge\n                'H' + pos0 + // bottom of the box\n                (notched ? 'V' + un + 'L' + posm0 + ',' + m + 'L' + pos0 + ',' + ln : '') + // notched left edge\n                'Z' + // end of the box\n                'M' + posc + ',' + q1 + 'V' + lf + 'M' + posc + ',' + q3 + 'V' + uf + // whiskers\n                ((whiskerWidth === 0) ? '' : // whisker caps\n                    'M' + posw0 + ',' + lf + 'H' + posw1 + 'M' + posw0 + ',' + uf + 'H' + posw1));\n        }\n    });\n}\n\nfunction plotPoints(sel, axes, trace, t) {\n    var xa = axes.x;\n    var ya = axes.y;\n    var bdPos = t.bdPos;\n    var bPos = t.bPos;\n\n    // to support violin points\n    var mode = trace.boxpoints || trace.points;\n\n    // repeatable pseudo-random number generator\n    Lib.seedPseudoRandom();\n\n    // since box plot points get an extra level of nesting, each\n    // box needs the trace styling info\n    var fn = function(d) {\n        d.forEach(function(v) {\n            v.t = t;\n            v.trace = trace;\n        });\n        return d;\n    };\n\n    var gPoints = sel.selectAll('g.points')\n        .data(mode ? fn : []);\n\n    gPoints.enter().append('g')\n        .attr('class', 'points');\n\n    gPoints.exit().remove();\n\n    var paths = gPoints.selectAll('path')\n        .data(function(d) {\n            var i;\n            var pts = d.pts2;\n\n            // normally use IQR, but if this is 0 or too small, use max-min\n            var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);\n            var minSpread = typicalSpread * 1e-9;\n            var spreadLimit = typicalSpread * JITTERSPREAD;\n            var jitterFactors = [];\n            var maxJitterFactor = 0;\n            var newJitter;\n\n            // dynamic jitter\n            if(trace.jitter) {\n                if(typicalSpread === 0) {\n                    // edge case of no spread at all: fall back to max jitter\n                    maxJitterFactor = 1;\n                    jitterFactors = new Array(pts.length);\n                    for(i = 0; i < pts.length; i++) {\n                        jitterFactors[i] = 1;\n                    }\n                } else {\n                    for(i = 0; i < pts.length; i++) {\n                        var i0 = Math.max(0, i - JITTERCOUNT);\n                        var pmin = pts[i0].v;\n                        var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);\n                        var pmax = pts[i1].v;\n\n                        if(mode !== 'all') {\n                            if(pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);\n                            else pmin = Math.max(pmin, d.uf);\n                        }\n\n                        var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;\n                        jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);\n\n                        jitterFactors.push(jitterFactor);\n                        maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);\n                    }\n                }\n                newJitter = trace.jitter * 2 / (maxJitterFactor || 1);\n            }\n\n            // fills in 'x' and 'y' in calcdata 'pts' item\n            for(i = 0; i < pts.length; i++) {\n                var pt = pts[i];\n                var v = pt.v;\n\n                var jitterOffset = trace.jitter ?\n                    (newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5)) :\n                    0;\n\n                var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);\n\n                if(trace.orientation === 'h') {\n                    pt.y = posPx;\n                    pt.x = v;\n                } else {\n                    pt.x = posPx;\n                    pt.y = v;\n                }\n\n                // tag suspected outliers\n                if(mode === 'suspectedoutliers' && v < d.uo && v > d.lo) {\n                    pt.so = true;\n                }\n            }\n\n            return pts;\n        });\n\n    paths.enter().append('path')\n        .classed('point', true);\n\n    paths.exit().remove();\n\n    paths.call(Drawing.translatePoints, xa, ya);\n}\n\nfunction plotBoxMean(sel, axes, trace, t) {\n    var posAxis = axes.pos;\n    var valAxis = axes.val;\n    var bPos = t.bPos;\n    var bPosPxOffset = t.bPosPxOffset || 0;\n\n    // to support violin mean lines\n    var mode = trace.boxmean || (trace.meanline || {}).visible;\n\n    // to support for one-sided box\n    var bdPos0;\n    var bdPos1;\n    if(Array.isArray(t.bdPos)) {\n        bdPos0 = t.bdPos[0];\n        bdPos1 = t.bdPos[1];\n    } else {\n        bdPos0 = t.bdPos;\n        bdPos1 = t.bdPos;\n    }\n\n    var paths = sel.selectAll('path.mean').data((\n        (trace.type === 'box' && trace.boxmean) ||\n        (trace.type === 'violin' && trace.box.visible && trace.meanline.visible)\n    ) ? Lib.identity : []);\n\n    paths.enter().append('path')\n        .attr('class', 'mean')\n        .style({\n            fill: 'none',\n            'vector-effect': 'non-scaling-stroke'\n        });\n\n    paths.exit().remove();\n\n    paths.each(function(d) {\n        var lcenter = posAxis.c2l(d.pos + bPos, true);\n        var posc = posAxis.l2p(lcenter) + bPosPxOffset;\n        var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;\n        var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;\n        var m = valAxis.c2p(d.mean, true);\n        var sl = valAxis.c2p(d.mean - d.sd, true);\n        var sh = valAxis.c2p(d.mean + d.sd, true);\n\n        if(trace.orientation === 'h') {\n            d3.select(this).attr('d',\n                'M' + m + ',' + pos0 + 'V' + pos1 +\n                (mode === 'sd' ?\n                    'm0,0L' + sl + ',' + posc + 'L' + m + ',' + pos0 + 'L' + sh + ',' + posc + 'Z' :\n                    '')\n            );\n        } else {\n            d3.select(this).attr('d',\n                'M' + pos0 + ',' + m + 'H' + pos1 +\n                (mode === 'sd' ?\n                    'm0,0L' + posc + ',' + sl + 'L' + pos0 + ',' + m + 'L' + posc + ',' + sh + 'Z' :\n                    '')\n            );\n        }\n    });\n}\n\nmodule.exports = {\n    plot: plot,\n    plotBoxAndWhiskers: plotBoxAndWhiskers,\n    plotPoints: plotPoints,\n    plotBoxMean: plotBoxMean\n};\n"]},"metadata":{},"sourceType":"script"}