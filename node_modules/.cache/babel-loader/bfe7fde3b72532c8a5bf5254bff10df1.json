{"ast":null,"code":"\"use strict\";\n\nvar esprima = require(\"esprima\");\n\nvar uniq = require(\"uniq\");\n\nvar PREFIX_COUNTER = 0;\n\nfunction CompiledArgument(name, lvalue, rvalue) {\n  this.name = name;\n  this.lvalue = lvalue;\n  this.rvalue = rvalue;\n  this.count = 0;\n}\n\nfunction CompiledRoutine(body, args, thisVars, localVars) {\n  this.body = body;\n  this.args = args;\n  this.thisVars = thisVars;\n  this.localVars = localVars;\n}\n\nfunction isGlobal(identifier) {\n  if (identifier === \"eval\") {\n    throw new Error(\"cwise-parser: eval() not allowed\");\n  }\n\n  if (typeof window !== \"undefined\") {\n    return identifier in window;\n  } else if (typeof global !== \"undefined\") {\n    return identifier in global;\n  } else if (typeof self !== \"undefined\") {\n    return identifier in self;\n  } else {\n    return false;\n  }\n}\n\nfunction getArgNames(ast) {\n  var params = ast.body[0].expression.callee.params;\n  var names = new Array(params.length);\n\n  for (var i = 0; i < params.length; ++i) {\n    names[i] = params[i].name;\n  }\n\n  return names;\n}\n\nfunction preprocess(func) {\n  var src = [\"(\", func, \")()\"].join(\"\");\n  var ast = esprima.parse(src, {\n    range: true\n  }); //Compute new prefix\n\n  var prefix = \"_inline_\" + PREFIX_COUNTER++ + \"_\"; //Parse out arguments\n\n  var argNames = getArgNames(ast);\n  var compiledArgs = new Array(argNames.length);\n\n  for (var i = 0; i < argNames.length; ++i) {\n    compiledArgs[i] = new CompiledArgument([prefix, \"arg\", i, \"_\"].join(\"\"), false, false);\n  } //Create temporary data structure for source rewriting\n\n\n  var exploded = new Array(src.length);\n\n  for (var i = 0, n = src.length; i < n; ++i) {\n    exploded[i] = src.charAt(i);\n  } //Local variables\n\n\n  var localVars = [];\n  var thisVars = [];\n  var computedThis = false; //Retrieves a local variable\n\n  function createLocal(id) {\n    var nstr = prefix + id.replace(/\\_/g, \"__\");\n    localVars.push(nstr);\n    return nstr;\n  } //Creates a this variable\n\n\n  function createThisVar(id) {\n    var nstr = \"this_\" + id.replace(/\\_/g, \"__\");\n    thisVars.push(nstr);\n    return nstr;\n  } //Rewrites an ast node\n\n\n  function rewrite(node, nstr) {\n    var lo = node.range[0],\n        hi = node.range[1];\n\n    for (var i = lo + 1; i < hi; ++i) {\n      exploded[i] = \"\";\n    }\n\n    exploded[lo] = nstr;\n  } //Remove any underscores\n\n\n  function escapeString(str) {\n    return \"'\" + str.replace(/\\_/g, \"\\\\_\").replace(/\\'/g, \"\\'\") + \"'\";\n  } //Returns the source of an identifier\n\n\n  function source(node) {\n    return exploded.slice(node.range[0], node.range[1]).join(\"\");\n  } //Computes the usage of a node\n\n\n  var LVALUE = 1;\n  var RVALUE = 2;\n\n  function getUsage(node) {\n    if (node.parent.type === \"AssignmentExpression\") {\n      if (node.parent.left === node) {\n        if (node.parent.operator === \"=\") {\n          return LVALUE;\n        }\n\n        return LVALUE | RVALUE;\n      }\n    }\n\n    if (node.parent.type === \"UpdateExpression\") {\n      return LVALUE | RVALUE;\n    }\n\n    return RVALUE;\n  } //Handle visiting a node\n\n\n  (function visit(node, parent) {\n    node.parent = parent;\n\n    if (node.type === \"MemberExpression\") {\n      //Handle member expression\n      if (node.computed) {\n        visit(node.object, node);\n        visit(node.property, node);\n      } else if (node.object.type === \"ThisExpression\") {\n        rewrite(node, createThisVar(node.property.name));\n      } else {\n        visit(node.object, node);\n      }\n    } else if (node.type === \"ThisExpression\") {\n      throw new Error(\"cwise-parser: Computed this is not allowed\");\n    } else if (node.type === \"Identifier\") {\n      //Handle identifier\n      var name = node.name;\n      var argNo = argNames.indexOf(name);\n\n      if (argNo >= 0) {\n        var carg = compiledArgs[argNo];\n        var usage = getUsage(node);\n\n        if (usage & LVALUE) {\n          carg.lvalue = true;\n        }\n\n        if (usage & RVALUE) {\n          carg.rvalue = true;\n        }\n\n        ++carg.count;\n        rewrite(node, carg.name);\n      } else if (isGlobal(name)) {//Don't rewrite globals\n      } else {\n        rewrite(node, createLocal(name));\n      }\n    } else if (node.type === \"Literal\") {\n      if (typeof node.value === \"string\") {\n        rewrite(node, escapeString(node.value));\n      }\n    } else if (node.type === \"WithStatement\") {\n      throw new Error(\"cwise-parser: with() statements not allowed\");\n    } else {\n      //Visit all children\n      var keys = Object.keys(node);\n\n      for (var i = 0, n = keys.length; i < n; ++i) {\n        if (keys[i] === \"parent\") {\n          continue;\n        }\n\n        var value = node[keys[i]];\n\n        if (value) {\n          if (value instanceof Array) {\n            for (var j = 0; j < value.length; ++j) {\n              if (value[j] && typeof value[j].type === \"string\") {\n                visit(value[j], node);\n              }\n            }\n          } else if (typeof value.type === \"string\") {\n            visit(value, node);\n          }\n        }\n      }\n    }\n  })(ast.body[0].expression.callee.body, undefined); //Remove duplicate variables\n\n\n  uniq(localVars);\n  uniq(thisVars); //Return body\n\n  var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars);\n  return routine;\n}\n\nmodule.exports = preprocess;","map":{"version":3,"sources":["/Users/leena/Downloads/MyProjectDemo/covidIndia/node_modules/cwise-parser/index.js"],"names":["esprima","require","uniq","PREFIX_COUNTER","CompiledArgument","name","lvalue","rvalue","count","CompiledRoutine","body","args","thisVars","localVars","isGlobal","identifier","Error","window","global","self","getArgNames","ast","params","expression","callee","names","Array","length","i","preprocess","func","src","join","parse","range","prefix","argNames","compiledArgs","exploded","n","charAt","computedThis","createLocal","id","nstr","replace","push","createThisVar","rewrite","node","lo","hi","escapeString","str","source","slice","LVALUE","RVALUE","getUsage","parent","type","left","operator","visit","computed","object","property","argNo","indexOf","carg","usage","value","keys","Object","j","undefined","routine","module","exports"],"mappings":"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","sourcesContent":["\"use strict\"\n\nvar esprima = require(\"esprima\")\nvar uniq = require(\"uniq\")\n\nvar PREFIX_COUNTER = 0\n\nfunction CompiledArgument(name, lvalue, rvalue) {\n  this.name = name\n  this.lvalue = lvalue\n  this.rvalue = rvalue\n  this.count = 0\n}\n\nfunction CompiledRoutine(body, args, thisVars, localVars) {\n  this.body = body\n  this.args = args\n  this.thisVars = thisVars\n  this.localVars = localVars\n}\n\nfunction isGlobal(identifier) {\n  if(identifier === \"eval\") {\n    throw new Error(\"cwise-parser: eval() not allowed\")\n  }\n  if(typeof window !== \"undefined\") {\n    return identifier in window\n  } else if(typeof global !== \"undefined\") {\n    return identifier in global\n  } else if(typeof self !== \"undefined\") {\n    return identifier in self\n  } else {\n    return false\n  }\n}\n\nfunction getArgNames(ast) {\n  var params = ast.body[0].expression.callee.params\n  var names = new Array(params.length)\n  for(var i=0; i<params.length; ++i) {\n    names[i] = params[i].name\n  }\n  return names\n}\n\nfunction preprocess(func) {\n  var src = [\"(\", func, \")()\"].join(\"\")\n  var ast = esprima.parse(src, { range: true })\n  \n  //Compute new prefix\n  var prefix = \"_inline_\" + (PREFIX_COUNTER++) + \"_\"\n  \n  //Parse out arguments\n  var argNames = getArgNames(ast)\n  var compiledArgs = new Array(argNames.length)\n  for(var i=0; i<argNames.length; ++i) {\n    compiledArgs[i] = new CompiledArgument([prefix, \"arg\", i, \"_\"].join(\"\"), false, false)\n  }\n  \n  //Create temporary data structure for source rewriting\n  var exploded = new Array(src.length)\n  for(var i=0, n=src.length; i<n; ++i) {\n    exploded[i] = src.charAt(i)\n  }\n  \n  //Local variables\n  var localVars = []\n  var thisVars = []\n  var computedThis = false\n  \n  //Retrieves a local variable\n  function createLocal(id) {\n    var nstr = prefix + id.replace(/\\_/g, \"__\")\n    localVars.push(nstr)\n    return nstr\n  }\n  \n  //Creates a this variable\n  function createThisVar(id) {\n    var nstr = \"this_\" + id.replace(/\\_/g, \"__\")\n    thisVars.push(nstr)\n    return nstr\n  }\n  \n  //Rewrites an ast node\n  function rewrite(node, nstr) {\n    var lo = node.range[0], hi = node.range[1]\n    for(var i=lo+1; i<hi; ++i) {\n      exploded[i] = \"\"\n    }\n    exploded[lo] = nstr\n  }\n  \n  //Remove any underscores\n  function escapeString(str) {\n    return \"'\"+(str.replace(/\\_/g, \"\\\\_\").replace(/\\'/g, \"\\'\"))+\"'\"\n  }\n  \n  //Returns the source of an identifier\n  function source(node) {\n    return exploded.slice(node.range[0], node.range[1]).join(\"\")\n  }\n  \n  //Computes the usage of a node\n  var LVALUE = 1\n  var RVALUE = 2\n  function getUsage(node) {\n    if(node.parent.type === \"AssignmentExpression\") {\n      if(node.parent.left === node) {\n        if(node.parent.operator === \"=\") {\n          return LVALUE\n        }\n        return LVALUE|RVALUE\n      }\n    }\n    if(node.parent.type === \"UpdateExpression\") {\n      return LVALUE|RVALUE\n    }\n    return RVALUE\n  }\n  \n  //Handle visiting a node\n  (function visit(node, parent) {\n    node.parent = parent\n    if(node.type === \"MemberExpression\") {\n      //Handle member expression\n      if(node.computed) {\n        visit(node.object, node)\n        visit(node.property, node)\n      } else if(node.object.type === \"ThisExpression\") {\n        rewrite(node, createThisVar(node.property.name))\n      } else {\n        visit(node.object, node)\n      }\n    } else if(node.type === \"ThisExpression\") {\n      throw new Error(\"cwise-parser: Computed this is not allowed\")\n    } else if(node.type === \"Identifier\") {\n      //Handle identifier\n      var name = node.name\n      var argNo = argNames.indexOf(name)\n      if(argNo >= 0) {\n        var carg = compiledArgs[argNo]\n        var usage = getUsage(node)\n        if(usage & LVALUE) {\n          carg.lvalue = true\n        }\n        if(usage & RVALUE) {\n          carg.rvalue = true\n        }\n        ++carg.count\n        rewrite(node, carg.name)\n      } else if(isGlobal(name)) {\n        //Don't rewrite globals\n      } else {\n        rewrite(node, createLocal(name))\n      }\n    } else if(node.type === \"Literal\") {\n      if(typeof node.value === \"string\") {\n        rewrite(node, escapeString(node.value))\n      }\n    } else if(node.type === \"WithStatement\") {\n      throw new Error(\"cwise-parser: with() statements not allowed\")\n    } else {\n      //Visit all children\n      var keys = Object.keys(node)\n      for(var i=0, n=keys.length; i<n; ++i) {\n        if(keys[i] === \"parent\") {\n          continue\n        }\n        var value = node[keys[i]]\n        if(value) {\n          if(value instanceof Array) {\n            for(var j=0; j<value.length; ++j) {\n              if(value[j] && typeof value[j].type === \"string\") {\n                visit(value[j], node)\n              }\n            }\n          } else if(typeof value.type === \"string\") {\n            visit(value, node)\n          }\n        }\n      }\n    }\n  })(ast.body[0].expression.callee.body, undefined)\n  \n  //Remove duplicate variables\n  uniq(localVars)\n  uniq(thisVars)\n  \n  //Return body\n  var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars)\n  return routine\n}\n\nmodule.exports = preprocess"]},"metadata":{},"sourceType":"script"}